<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>å¹»æƒ³æœº - æ›¹åƒ§ (æ·±ç©ºé€è§† v6.8)</title>
    <style>
        /* --- åŸºç¡€æ ·å¼ --- */
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #020204; font-family: "PingFang SC", "Microsoft YaHei", sans-serif; user-select: none; -webkit-user-select: none; }
        
        /* å®¹å™¨ */
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #css3d-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; } 
        
        /* --- UI å±‚ (HUD) --- */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; }
        #ui-layer.hidden { display: none; }

        /* å…¨å±è¦†ç›–å±‚ - é€šç”¨ */
        .overlay-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, rgba(10, 20, 40, 0.3) 0%, rgba(0, 0, 0, 0.85) 100%);
            backdrop-filter: blur(2px);
            z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; pointer-events: auto; 
            opacity: 1; visibility: visible;
            transition: opacity 0.8s, visibility 0s 0s;
            overflow: hidden; 
        }
        .overlay-screen.hidden { 
            opacity: 0; pointer-events: none; 
            visibility: hidden; 
            transition: opacity 0.8s, visibility 0s 0.8s;
        }

        /* æ¬¢è¿ç•Œé¢è§’è‰²å±‚ */
        #welcome-actors { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 5; }
        .actor { position: absolute; font-size: 2rem; will-change: transform; }
        .rocket-crashed { transition: transform 0.5s ease; filter: grayscale(100%) brightness(0.5); }

        /* --- 1. å¤ªç©ºç§‘å¹»æ„Ÿæ ‡é¢˜ --- */
        .glitch-title {
            font-size: 4rem; font-weight: 900; position: relative; letter-spacing: 15px; text-indent: 15px;
            background: linear-gradient(to bottom, #ffffff 0%, #b3e5fc 50%, #4fc3f7 100%);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 20px rgba(79, 195, 247, 0.8));
            animation: glitch-skew 4s infinite linear alternate-reverse; z-index: 20; margin-bottom: 10px;
        }
        .glitch-title::before, .glitch-title::after {
            content: attr(data-text); position: absolute; left: 0; top: 0; width: 100%; height: 100%;
            background: transparent; overflow: hidden; clip: rect(0, 900px, 0, 0);
            -webkit-text-fill-color: #fff;
        }
        .glitch-title::before { left: 2px; text-shadow: -2px 0 #ff0055; animation: glitch-anim-1 2s infinite linear alternate-reverse; }
        .glitch-title::after { left: -2px; text-shadow: -2px 0 #4fc3f7; animation: glitch-anim-2 3s infinite linear alternate-reverse; }

        /* --- 2. å‰¯æ ‡é¢˜ --- */
        .subtitle { 
            font-family: "Courier New", "Consolas", monospace;
            font-size: 0.9rem; 
            color: #81d4fa; 
            margin-top: 10px; margin-bottom: 3rem; 
            letter-spacing: 4px; text-align: center; max-width: 80%; line-height: 1.8; 
            text-transform: uppercase;
            background: repeating-linear-gradient(to bottom, transparent 0px, transparent 2px, rgba(79, 195, 247, 0.1) 2px, rgba(79, 195, 247, 0.1) 4px);
            border-top: 1px solid rgba(79, 195, 247, 0.5); border-bottom: 1px solid rgba(79, 195, 247, 0.5);
            /* ä¿®æ”¹ç‚¹ï¼šç¼©å°ä¸Šä¸‹å†…è¾¹è· (åŸ20px -> 12px) */
            padding: 12px 40px; 
            z-index: 20;
            text-shadow: 0 0 4px rgba(79, 195, 247, 0.8);
            animation: holo-flicker 5s infinite; 
        }

        @keyframes holo-flicker {
            0%, 100% { opacity: 1; text-shadow: 0 0 4px rgba(79, 195, 247, 0.8); }
            50% { opacity: 0.7; text-shadow: 0 0 2px rgba(79, 195, 247, 0.4); }
            52% { opacity: 0.2; } 90% { opacity: 0.9; } 94% { opacity: 1; }
        }

        /* --- 3. æŒ‰é’®ç³»ç»Ÿ --- */
        .btn-wrapper, .btn-small-wrapper {
            position: relative; z-index: 30; margin-top: 15px; display: inline-block;
        }

        @keyframes engine-breathe {
            0%, 100% {
                transform: scale(1);
                text-shadow: 0 0 5px rgba(79, 195, 247, 0.5);
                box-shadow: 0 0 10px rgba(0, 0, 0, 0.8), inset 0 0 10px rgba(79, 195, 247, 0.1);
                border-color: rgba(79, 195, 247, 0.3);
                border-left-color: #37474f; border-right-color: #37474f;
            }
            50% {
                transform: scale(1.05);
                text-shadow: 0 0 15px rgba(255, 255, 255, 0.9), 0 0 30px #4fc3f7;
                box-shadow: 0 0 40px rgba(79, 195, 247, 0.5), inset 0 0 30px rgba(79, 195, 247, 0.2);
                border-color: rgba(79, 195, 247, 0.8);
                border-left-color: #4fc3f7; border-right-color: #4fc3f7;
            }
        }

        @keyframes collage-breathe {
            0%, 100% {
                transform: scale(1);
                text-shadow: 0 0 2px rgba(255, 153, 204, 0.3);
                border-color: rgba(255, 153, 204, 0.3);
                box-shadow: 0 0 15px rgba(255, 51, 102, 0.2), inset 0 0 5px rgba(255, 51, 102, 0.1);
            }
            50% {
                transform: scale(1.05);
                text-shadow: 0 0 15px rgba(255, 255, 255, 0.9), 0 0 30px #ff3366;
                border-color: rgba(255, 153, 204, 1);
                box-shadow: 0 0 25px rgba(255, 51, 102, 0.5), inset 0 0 10px rgba(255, 51, 102, 0.3);
            }
        }

        .btn-inner {
            position: relative; padding: 12px 15px; 
            font-size: 1.4rem; font-weight: 900; color: #4fc3f7;
            background: repeating-linear-gradient(45deg, rgba(0, 0, 0, 0.3), rgba(0, 0, 0, 0.3) 10px, rgba(79, 195, 247, 0.05) 10px, rgba(79, 195, 247, 0.05) 20px), linear-gradient(180deg, #16222e 0%, #050a10 100%);
            border-top: 1px solid rgba(79, 195, 247, 0.3); border-bottom: 1px solid rgba(79, 195, 247, 0.3);
            border-left: 5px solid #37474f; border-right: 5px solid #37474f; 
            cursor: pointer; text-transform: uppercase;
            letter-spacing: 12px; text-indent: 12px;
            animation: engine-breathe 2.5s ease-in-out infinite;
            clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
            display: flex; justify-content: center; align-items: center; transition: all 0.3s;
        }
        
        .btn-inner::before {
            content: ''; position: absolute; top: 2px; bottom: 2px; left: 2px; right: 2px;
            background: linear-gradient(135deg, transparent 15px, rgba(79,195,247,0.1) 15px, rgba(79,195,247,0.1) 16px, transparent 16px), linear-gradient(-45deg, transparent 15px, rgba(79,195,247,0.1) 15px, rgba(79,195,247,0.1) 16px, transparent 16px);
            z-index: 1; pointer-events: none;
        }

        .btn-wrapper:hover .btn-inner {
            animation: none; transform: scale(1.1);
            background: repeating-linear-gradient(45deg, rgba(79, 195, 247, 0.1), rgba(79, 195, 247, 0.1) 10px, transparent 10px, transparent 20px), linear-gradient(180deg, #1a3a5a 0%, #0a1520 100%);
            border-color: #4fc3f7; border-left-color: #fff; border-right-color: #fff;
            letter-spacing: 14px; text-indent: 14px; color: #fff;
            text-shadow: 0 0 20px rgba(255, 255, 255, 1);
            box-shadow: 0 0 50px rgba(79, 195, 247, 0.8), inset 0 0 20px rgba(79, 195, 247, 0.5);
        }
        .btn-wrapper:active .btn-inner { transform: scale(0.96); border-left-width: 2px; border-right-width: 2px; }

        .btn-small-wrapper { margin-bottom: 20px; }
        .btn-inner-small {
            position: relative; padding: 6px 10px; 
            font-size: 1.0rem; font-weight: 600; color: #ff99cc;
            background: rgba(30, 10, 20, 0.6); cursor: pointer;
            letter-spacing: 2px; text-transform: uppercase; transition: all 0.3s;
            border: 1px dashed rgba(255, 153, 204, 0.3); border-left: 3px solid #ff99cc; 
            animation: collage-breathe 2.5s ease-in-out infinite; animation-delay: 1.25s;
            background-image: repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(255, 153, 204, 0.05) 2px, rgba(255, 153, 204, 0.05) 4px);
        }
        .btn-inner-small:hover {
            animation: none; transform: scale(1.1);
            background-color: rgba(255, 153, 204, 0.15); border-left-width: 6px; border-style: solid; color: #fff;
            box-shadow: 0 0 25px rgba(255, 51, 102, 0.6), inset 0 0 10px rgba(255, 51, 102, 0.4); letter-spacing: 3px;
        }

        /* å®‡èˆªå‘˜ */
        .walker-astronaut {
            position: absolute; font-size: 1.2rem; width: 20px; height: 20px;
            line-height: 20px; text-align: center; top: 0; left: 0; 
            pointer-events: none; z-index: 40;
            transition: transform 0.05s linear; filter: drop-shadow(0 0 2px rgba(255,255,255,0.8));
            transform-origin: center bottom;
        }

        /* åº•éƒ¨æ˜Ÿå…‰æ–‡å­— */
        .footer-starlight {
            position: absolute; 
            bottom: 40px; 
            left: 0;                  /* æ–°å¢ï¼šé å·¦å¯¹é½ */
            width: 100%;             /* æ–°å¢ï¼šå®½åº¦å æ»¡å…¨å± */
            text-align: center;      /* æ–°å¢ï¼šæ–‡å­—å±…ä¸­ */
            text-indent: 8px;        /* æ–°å¢ï¼šæŠµæ¶ˆ letter-spacing äº§ç”Ÿçš„å³ä¾§ç©ºéš™ï¼Œç¡®ä¿ç»å¯¹è§†è§‰å±…ä¸­ */
            font-size: 0.9rem; 
            color: rgba(255, 255, 255, 0.6);
            letter-spacing: 8px; 
            font-weight: 300; 
            animation: starlight-breathe 4s ease-in-out infinite;
            z-index: 20; 
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.3);
        }
        @keyframes starlight-breathe {
            0%, 100% { opacity: 0.4; transform: scale(0.98); }
            50% { opacity: 1; transform: scale(1); text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px #4fc3f7; }
        }

        /* Glitch Keyframes */
        @keyframes glitch-anim-1 { 0% { clip: rect(20px, 9999px, 10px, 0); } 20% { clip: rect(60px, 9999px, 100px, 0); } 40% { clip: rect(10px, 9999px, 80px, 0); } 60% { clip: rect(80px, 9999px, 20px, 0); } 80% { clip: rect(40px, 9999px, 60px, 0); } 100% { clip: rect(50px, 9999px, 30px, 0); } }
        @keyframes glitch-anim-2 { 0% { clip: rect(80px, 9999px, 20px, 0); } 20% { clip: rect(10px, 9999px, 80px, 0); } 40% { clip: rect(50px, 9999px, 30px, 0); } 60% { clip: rect(20px, 9999px, 90px, 0); } 80% { clip: rect(60px, 9999px, 10px, 0); } 100% { clip: rect(30px, 9999px, 60px, 0); } }
        @keyframes glitch-skew { 0%, 30%, 90% { transform: skew(0deg); } 10% { transform: skew(-2deg); } 20% { transform: skew(1deg); } 100% { transform: skew(2deg); } }

        /* --- å¤‡é€‰æ  --- */
        #selection-bar {
            position: absolute; bottom: 30px; left: 30px; top: auto; width: 180px; height: auto; 
            background: rgba(10, 20, 35, 0.15); backdrop-filter: blur(2px);
            border: 1px solid rgba(79, 195, 247, 0.15); border-radius: 15px;
            padding: 12px 10px 6px 10px; display: flex; flex-direction: column; align-items: center;
            justify-content: flex-start;
            pointer-events: auto; transition: transform 0.3s; box-shadow: 0 0 20px rgba(0,0,0,0.2); z-index: 20;
        }
        .slot-container { width: 100%; display: flex; flex-direction: column; align-items: center; gap: 6px; min-height: auto; /* å°† 50px æ”¹ä¸º auto */}
        .slot-placeholder { color: rgba(255,255,255,0.3); font-size: 0.75rem; font-style: italic; margin-bottom: 0px; text-align: center; }

        /* Toast */
        #toast {
            position: absolute; top: 50%; left: 30px; 
            /* ä¿®æ”¹ç‚¹ï¼šå®½åº¦æ”¹ä¸º180pxä»¥å¯¹é½å¤‡é€‰æ  */
            width: 200px; 
            height: 50px; box-sizing: border-box;
            background: rgba(10, 15, 20, 0.95); border-right: 1px solid rgba(79, 195, 247, 0.3); border-bottom: 1px solid rgba(79, 195, 247, 0.3); border-left: 4px solid #4fc3f7; 
            color: #4fc3f7; clip-path: polygon(0 0, 100% 0, 100% 70%, 90% 100%, 0 100%);
            /* ä¿®æ”¹ç‚¹ï¼šå†…è¾¹è·ä¸Šä¸‹ç¼©å°10% (8->7) */
            display: flex; flex-direction: column; justify-content: center; padding: 7px 16px;
            font-family: "PingFang SC", monospace; letter-spacing: 1px; 
            opacity: 0; transform: translateY(-50%) translateX(-20px) scale(0.9); 
            pointer-events: none; z-index: 60; filter: drop-shadow(0 0 8px rgba(79, 195, 247, 0.4));
            background-image: repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(79, 195, 247, 0.05) 2px, rgba(79, 195, 247, 0.05) 4px);
        }
        #toast.visible { animation: glitch-in 0.3s cubic-bezier(0.2, 0.8, 0.2, 1) forwards; }
        .toast-label { font-size: 0.5rem; opacity: 0.7; margin-bottom: 2px; display: block; text-transform: uppercase; }
        .toast-message { font-size: 0.85rem; font-weight: 900; line-height: 1.2; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.8); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        #toast.success { border-left-color: #00ff44; } #toast.success .toast-message { text-shadow: 0 0 10px #00ff44; }
        #toast.error { border-left-color: #ff3333; background: rgba(20, 5, 5, 0.95); } #toast.error .toast-message { text-shadow: 0 0 10px #ff3333; }
        #toast.warning { border-left-color: #ffaa00; } #toast.warning .toast-message { text-shadow: 0 0 10px #ffaa00; }
        @keyframes glitch-in { 
            0% { opacity: 0; transform: translateY(-50%) scale(0.8) translateX(-50px); filter: blur(10px); } 
            100% { opacity: 1; transform: translateY(-50%) scale(1) translateX(0); } 
        }

        /* ç¡®è®¤æŒ‰é’® & åŠ¨ç”» */
        @keyframes btn-pulse-anim {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px currentColor; text-shadow: 0 0 5px currentColor; }
            50% { transform: scale(1.08); box-shadow: 0 0 25px currentColor; text-shadow: 0 0 15px currentColor; }
        }

        #confirm-btn {
            margin-top: 8px; opacity: 0; pointer-events: none; height: 0; padding: 0; overflow: hidden; 
            transform: translateY(10px); transition: all 0.3s; font-size: 0.8rem;
            /* ä¿®æ”¹ç‚¹ï¼šæ¢å¤è¾¹æ¡† (border-bottom: 1px solid) */
            border: 1px solid #66ff66; border-bottom: 1px solid currentColor;
            color: #66ff66; background: rgba(0,0,0,0.5); width: 90%; text-align: center; border-radius: 20px; z-index: 100;
        }
        #confirm-btn.visible { 
            opacity: 1; pointer-events: auto; transform: translateY(0); height: auto;
            padding: 6px 15px; margin-bottom: 6px; 
            animation: btn-pulse-anim 2s infinite ease-in-out;
        }

        #hint-btn {
            position: absolute; bottom: 100%; margin-bottom: 10px; padding: 8px 20px;
            background: rgba(255, 215, 0, 0.2); border: 1px solid #ffd700; color: #ffd700;
            border-radius: 20px; font-size: 0.9rem; cursor: pointer; opacity: 0; pointer-events: none; transform: translateY(10px);
            transition: all 0.3s; box-shadow: 0 0 10px rgba(255, 215, 0, 0.3); white-space: nowrap;
        }
        #hint-btn.visible { opacity: 1; pointer-events: auto; transform: translateY(0); }

        /* 3D æ–‡å­—å¡ç‰‡ */
        .asteroid-card {
            background: rgba(5, 25, 45, 0.6); color: rgba(235, 250, 255, 1);
            text-shadow: 0 0 5px rgba(0,0,0,0.8), 0 0 8px rgba(79, 195, 247, 0.8); 
            padding: 5px 12px; border-radius: 8px; border: none; text-align: center; white-space: nowrap; cursor: pointer; 
            pointer-events: auto; transition: opacity 0.3s, transform 0.3s; backface-visibility: hidden;
            font-weight: bold; display: flex; align-items: center; gap: 10px; transform-style: preserve-3d; opacity: 0;
        }
        .asteroid-card.active-reading { opacity: 1 !important; background: rgba(10, 30, 50, 0.85);
        box-shadow: 0 0 20px rgba(79, 195, 247, 0.4); z-index: 100; }

        /* å¤‡é€‰æ å¡ç‰‡ */
        .slot-card {
            background: rgba(79, 195, 247, 0.25); border: none; color: #fff; padding: 6px 10px; 
            font-size: 0.75rem; width: auto; max-width: 98%; text-align: center;
            animation: popIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            cursor: grab; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; border-radius: 4px;
            border: 1px solid transparent; transition: all 0.3s;
        }
        .slot-card.dragging { opacity: 0.6; background: rgba(255, 215, 0, 0.35); border: 1px dashed #ffd700; cursor: grabbing; }
        .slot-card.drag-over { border-top: 2px solid #4fc3f7; }
        @keyframes popIn { from { transform: scale(0.5); opacity: 0; } to { transform: scale(1); opacity: 1; } }

        /* æç¤ºé«˜äº® */
        @keyframes breathe-glow {
            0% { transform: scale(1); box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); border-color: rgba(255, 215, 0, 0.5); color: #ffd700; }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(255, 215, 0, 1); border-color: #ffd700; color: #fff; }
            100% { transform: scale(1); box-shadow: 0 0 5px rgba(255, 215, 0, 0.5); border-color: rgba(255, 215, 0, 0.5); color: #ffd700; }
        }
        .hint-active { animation: breathe-glow 1.5s infinite ease-in-out !important; z-index: 10; }

        /* è¿›åº¦æ¡ */
        #progress-bar { 
            position: absolute; top: 25px; right: 25px; width: 120px; height: 6px; 
            background: rgba(30, 40, 60, 0.8); border: 1px solid rgba(79, 195, 247, 0.3);
            border-radius: 3px; z-index: 50;
        }
        #progress-fill { width: 0%; height: 100%; background: #4fc3f7; transition: width 0.5s; box-shadow: 0 0 5px #4fc3f7; }
        
/* --- æ‰¾åˆ°åŸæœ‰ #warp-overlay ä»£ç å—ï¼Œæ›¿æ¢ä¸ºä»¥ä¸‹å†…å®¹ --- */
#warp-overlay { 
    position: absolute; top:0; left:0; width:100%; height:100%; 
    /* ä¿®æ”¹ç‚¹ 1: è¿™æ˜¯ä¸€ä¸ªå¾„å‘å…‰æŸèƒŒæ™¯ï¼Œæ¨¡æ‹Ÿå…‰éš§é“ */
    background: radial-gradient(circle at center, 
        rgba(255, 255, 255, 1) 0%, 
        rgba(200, 245, 255, 0.9) 20%, 
        rgba(79, 195, 247, 0.6) 40%, 
        rgba(79, 195, 247, 0) 70%);
    
    opacity: 0; pointer-events: none; z-index: 300; 
    
    /* ä¿®æ”¹ç‚¹ 2: ä½¿ç”¨ screen è®©å…‰æ•ˆå åŠ æ›´äº® */
    mix-blend-mode: screen; 
    
    /* åˆå§‹çŠ¶æ€ç¼©å°ä¸º0 */
    transform: scale(0);
    transform-origin: center;
}

#warp-overlay.stream-active { 
    /* ä¿®æ”¹ç‚¹ A: å°†åŠ¨ç”»æ€»æ—¶é•¿ä» 1.2s å»¶é•¿è‡³ 4.5s */
    animation: warp-stream-anim 4.5s cubic-bezier(0.1, 0.9, 0.2, 1) forwards; 
}

/* --- æ‰¾åˆ°åŸæœ‰ @keyframes warp-stream-anim ä»£ç å—ï¼Œæ›¿æ¢ä¸ºä»¥ä¸‹å†…å®¹ --- */
@keyframes warp-stream-anim {
    0% { 
        opacity: 0; 
        transform: scale(0); /* èµ·å§‹ï¼šæå° */
    }
    10% {
        opacity: 1; /* ç¬é—´å˜äº® */
    }
    50% { 
        opacity: 1; 
        transform: scale(4); /* ä¸­é—´ï¼šå…‰æŸæ‰©æ•£è¦†ç›–å…¨å± */
    }
    /* ä¿®æ”¹ç‚¹ C: å¢åŠ ä¸€ä¸ªä¸­é—´ç‚¹ï¼Œä½¿å…‰æŸæŒç»­è‡³ 1.2s (1.8s * 67%) å·¦å³ */
    67% { 
        opacity: 1; 
        transform: scale(4); 
    }
    100% { 
        opacity: 0; 
        transform: scale(6); /* ç»“æŸï¼šç»§ç»­æ‰©æ•£ç›´è‡³æ¶ˆå¤± */
    }
}
        /* çŸ¿çŸ³è®¡æ•°å™¨ */
        #ore-counter {
            position: absolute; top: 20px; left: 20px; 
            display: none; align-items: center; gap: 10px;
            background: rgba(5, 15, 25, 0.85); backdrop-filter: blur(4px);
            border: 1px solid rgba(79, 195, 247, 0.3); border-left: 4px solid #4fc3f7;
            padding: 8px 20px; border-radius: 2px;
            clip-path: polygon(0 0, 100% 0, 100% 70%, 85% 100%, 0 100%);
            cursor: pointer; pointer-events: auto; z-index: 200;
            box-shadow: 0 0 15px rgba(79, 195, 247, 0.2), inset 0 0 20px rgba(79, 195, 247, 0.05);
            transition: all 0.3s;
        }
        #ore-counter:hover {
            background: rgba(10, 50, 90, 0.95); box-shadow: 0 0 20px rgba(79, 195, 247, 0.6); padding-left: 25px;
        }
        .ore-icon { font-size: 1.2rem; }
        .ore-count { color: #4fc3f7; font-size: 1.1rem; font-weight: bold; font-family: monospace; }
        .ore-icon.red { text-shadow: 0 0 10px #ff3366; filter: hue-rotate(140deg); }

        /* æœºæ¢°æ“ä½œæŒ‰é’® */
        #controls-container {
            position: absolute; bottom: 30px; right: 30px; 
            display: flex; flex-direction: column; gap: 12px; align-items: flex-end;
            z-index: 50; pointer-events: auto;
        }
        .hud-btn {
            /* ä¿®æ”¹ç‚¹ï¼šå®½åº¦æ‰©å±•10% (112 * 1.1 â‰ˆ 124px) */
            width: 124px; 
            height: 36px; padding: 0; margin: 0;
            display: flex; justify-content: center; align-items: center;
            font-size: 0.7rem; font-family: "Courier New", "PingFang SC", monospace;
            letter-spacing: 1px; font-weight: 800; text-transform: uppercase;
            background: linear-gradient(90deg, rgba(5, 10, 15, 0.9) 0%, rgba(20, 30, 40, 0.95) 50%, rgba(5, 10, 15, 0.9) 100%);
            border: 1px solid rgba(79, 195, 247, 0.2); border-left: none; color: #4fc3f7;
            clip-path: polygon(0 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%);
            transition: all 0.2s ease; cursor: pointer; position: relative;
        }
        .hud-btn::before { content: ''; position: absolute; left: 0; top: 0; width: 4px; height: 100%; background: currentColor; opacity: 0.8; box-shadow: 2px 0 5px currentColor; }
        .hud-btn::after { content: ''; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-image: linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px), linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px); background-size: 4px 4px; z-index: -1; }
        .hud-btn:hover { background: rgba(79, 195, 247, 0.1); text-shadow: 0 0 8px currentColor; letter-spacing: 2px; padding-left: 5px; }
        .hud-btn:active { transform: scale(0.98); }
        #refresh-btn { color: #4fc3f7; }
        #mode-switch-btn { color: #e0e0e0; } #mode-switch-btn::before { background: #e0e0e0; }
        #home-btn { color: #ffcc99; } #home-btn::before { background: #ff9966; }
        
        /* æ”¶é›†åˆ—è¡¨æ¨¡æ€æ¡† */
        #collection-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); backdrop-filter: blur(5px); z-index: 250; 
            display: flex; justify-content: center; align-items: center;
            opacity: 0; visibility: hidden; pointer-events: none; transition: opacity 0.3s, visibility 0s 0.3s;
        }
        #collection-modal.visible { opacity: 1; visibility: visible; pointer-events: auto; transition: opacity 0.3s, visibility 0s 0s; }
        
        .collection-panel { width: 80%; max-width: 500px; max-height: 80%; background: rgba(25, 35, 55, 0.95); border: 1px solid #4fc3f7; border-radius: 10px; padding: 20px; display: flex; flex-direction: column; box-shadow: 0 0 30px rgba(0,0,0,0.8); }
        .collection-header { font-size: 1.2rem; color: #fff; margin-bottom: 15px; text-align: center; border-bottom: 1px solid rgba(255,255,255,0.1); padding-bottom: 10px; }
        .collection-controls { display: flex; justify-content: space-between; align-items: flex-start; padding-bottom: 15px; margin-bottom: 15px; border-bottom: 1px dashed rgba(79, 195, 247, 0.2); }
        .control-message { font-size: 0.75rem; color: #bbb; max-width: 60%; line-height: 1.4; }
        
        #download-all-btn { 
            padding: 8px 15px; font-size: 0.8rem; border-radius: 5px; height: 35px; margin-left: 10px;
            border: none !important;
            background: rgba(79, 195, 247, 0.4);
            color: #fff;
            cursor: pointer;
            transition: all 0.3s;
        }
        #download-all-btn:hover {
            background: rgba(79, 195, 247, 0.7);
        }
        
        .collection-list { flex: 1; overflow-y: auto; padding-right: 5px; }
        .collection-item {
            padding: 12px; margin-bottom: 8px; background: rgba(255,255,255,0.08); border-radius: 5px;
            cursor: pointer; transition: background 0.2s; color: #ddd; font-size: 0.9rem;
            display: flex; align-items: center; justify-content: space-between;
        }
        .collection-item:hover { background: rgba(79, 195, 247, 0.2); color: #fff; }
        .collection-item.collage-item { border-left: 3px solid #ff3366; }
        .collection-item.collage-item:hover { background: rgba(255, 51, 102, 0.2); }
        
        .collection-idx { color: #4fc3f7; font-weight: bold; margin-right: 10px; }
        .collage-item .collection-idx { color: #ff3366; }

        .download-btn-small {
            padding: 4px 10px; font-size: 0.75rem; color: #66ff66; border: 1px solid #66ff66; background: rgba(102, 255, 102, 0.1);
            border-radius: 3px; cursor: pointer; transition: all 0.2s;
        }
        .download-btn-small:hover { background: rgba(102, 255, 102, 0.3); }

        /* è¯—æ­Œç»“æ™¶å¡ç‰‡ */
        #crystal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.92); z-index: 200; 
            display: flex; justify-content: center; align-items: center; opacity: 0;
            visibility: hidden; pointer-events: none;
            transition: opacity 0.5s ease, visibility 0s 0.5s; backdrop-filter: blur(10px);
        }
        #crystal-overlay.visible { opacity: 1; visibility: visible; pointer-events: auto; transition: opacity 0.5s ease, visibility 0s 0s; }

        .crystal-card-body {
            width: 80%; max-width: 360px; padding: 50px 30px; border-radius: 12px;
            text-align: center; color: #fff; position: relative; overflow: hidden;
            border: 1px solid rgba(255,255,255,0.2);
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            transform: scale(0.9); transition: transform 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); cursor: pointer;
        }
        #crystal-overlay.visible .crystal-card-body { transform: scale(1); }
        .crystal-card-body::before {
            content: ''; position: absolute; top: -50%; left: -50%; width: 200%; height: 200%;
            background: radial-gradient(circle at center, rgba(255,255,255,0.1) 0%, transparent 70%); pointer-events: none;
        }
        .crystal-text { font-size: 1.4rem; line-height: 2; text-shadow: 0 0 15px rgba(255,255,255,0.6);
        font-family: "Songti SC", "SimSun", "Times New Roman", serif; position: relative; z-index: 2; letter-spacing: 2px;
        }
        .crystal-hint { margin-top: 40px; font-size: 0.75rem; color: rgba(255,255,255,0.4); text-transform: uppercase; letter-spacing: 3px;
        position: relative; z-index: 2; }
/* [æ–°å¢] ä¿å­˜å›¾ç‰‡æŒ‰é’®æ ·å¼ */
        .save-img-btn {
            margin-top: 15px; padding: 8px 20px;
            font-size: 0.8rem; background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.4); color: #fff;
            border-radius: 20px; cursor: pointer; text-transform: uppercase;
            letter-spacing: 2px; transition: all 0.3s;
            position: relative; z-index: 10; pointer-events: auto;
        }
        .save-img-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
        }

        /* --- [æ–°å¢] æ°›å›´ç‰¹æ•ˆæ ·å¼ --- */
        #background-fx-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; pointer-events: none; overflow: hidden;
        }
        .bg-floater {
               position: absolute; font-size: 2rem; opacity: 0.8; /* æ”¹ä¸ºå¯è§ */
               will-change: transform, opacity; filter: drop-shadow(0 0 4px rgba(255,255,255,0.2));
               z-index: 1; /* ç¡®ä¿å®ƒä»¬ä¸ä¼šè¢«èƒŒæ™¯å®Œå…¨é®æŒ¡ */
         }
        /* 3D è§’è‰²å¡ç‰‡ */
        .actor-3d {
            font-size: 28px; pointer-events: none; 
            display: flex; align-items: center; justify-content: center;
            width: 40px; height: 40px;
            filter: drop-shadow(0 0 10px rgba(79, 195, 247, 0.6));
        }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/renderers/CSS3DRenderer.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

    <div id="background-fx-layer"></div>

    <div id="canvas-container"></div>
    <div id="css3d-container"></div>

    <div id="ore-counter" onclick="SoundManager.playCrystal(); toggleCollection()" onmouseenter="SoundManager.playHover()">
        <span class="ore-icon" id="main-ore-icon">ğŸ’</span>
        <span class="ore-count" id="ore-num">0</span>
    </div>

    <div id="ui-layer">
        <div id="selection-bar">
            <div id="hint-btn" onclick="SoundManager.playHover(); triggerHint()" onmouseenter="SoundManager.playHover()">ğŸ’¡ æç¤º</div>
        
            <div class="slot-container" id="slot-area">
                <div class="slot-placeholder">ç‚¹å‡»ç©ºä¸­çš„çŸ¿çŸ³æç‚¼...</div>
            </div>
            <div id="confirm-btn" class="btn-inner" style="border-radius:20px; width:90%; padding: 6px 15px;">æç‚¼è¯—æ­Œæ™¶ä½“</div>
        </div>
        
        <div id="toast">
            <span class="toast-label">SYSTEM_ALERT //</span>
            <span class="toast-message" id="toast-message">SYSTEM READY</span>
        </div>
        
        <div id="progress-bar"><div id="progress-fill"></div></div>
        
        <div id="controls-container">
             <div class="hud-btn" id="refresh-btn" onclick="SoundManager.playHover(); GameController.refreshLevel()" onmouseenter="SoundManager.playHover()">
             	     <span>â†»</span> åˆ‡æ¢çŸ¿åŒº
             </div>
             <div class="hud-btn" id="mode-switch-btn" onclick="SoundManager.playHover(); GameController.switchGameMode()" onmouseenter="SoundManager.playHover()">
                     <span>â‡„</span> åˆ‡æ¢æ¨¡å¼
             </div>
             <div class="hud-btn" id="home-btn" onclick="SoundManager.playHover(); GameController.returnToHome()" onmouseenter="SoundManager.playHover()">
                     <span>ğŸš€</span> è¿”èˆªæ¯æ˜Ÿ
             </div>
        </div>
    </div>

    <div id="collection-modal" onclick="toggleCollection()">
        <div class="collection-panel" onclick="event.stopPropagation()">
            <div class="collection-header">å·²æ”¶é›†çš„è¯—æ­Œæ™¶ä½“</div>
            
            <div class="collection-controls">
                <div class="control-message">æ‚¨çš„æ•°æ®åœ¨é€€å‡ºåä¸ä¼šè¢«ä¿å­˜ï¼Œå¦‚æœ‰éœ€è¦å¯ä»¥ä¸‹è½½</div>
                <button id="download-all-btn" onclick="SoundManager.playHover(); downloadAllPoems()" onmouseenter="SoundManager.playHover()">å­˜å‚¨å…¨éƒ¨è¯—æ­Œæ™¶ä½“/æ–‡æœ¬</button>
            </div>
            
            <div class="collection-list" id="collection-list"></div>
        </div>
    </div>

    <div id="crystal-overlay" onclick="closeCrystalCard()">
        <div class="crystal-card-body" id="crystal-card-content">
            <div class="crystal-text" id="crystal-text-content"></div>
            <div class="crystal-hint">ç‚¹å‡»ç©ºç™½å¤„å°†æ™¶ä½“å…¥åº“</div>
        </div>
    </div>

    <div id="start-screen" class="overlay-screen">
        
        <div id="welcome-actors">
            <div class="actor" id="rocket" style="left: -100px;">ğŸš€</div>
            <div class="actor" id="satellite" style="left: -100px;">ğŸ›°ï¸</div>
            <div class="actor" id="ufo" style="left: -100px;">ğŸ›¸</div>
        </div>

        <div class="glitch-title" data-text="å¹» æƒ³ æœº">å¹» æƒ³ æœº</div>
        <div class="subtitle">æ¬¢è¿é©¾é©¶æ›¹åƒ§å·å¹»æƒ³æœº<br>åœ¨æ˜Ÿé™…åºŸå¢Ÿä¸­æç‚¼å¤±è½çš„è¯—æ­Œæ™¶ä½“</div>
        
        <div class="btn-small-wrapper" onclick="GameController.startFirstRound('collage')" onmouseenter="SoundManager.playHover()">
            <div class="btn-inner-small">âœ¦ æ‹¼è´´è¯—æ¨¡å¼ âœ¦</div>
        </div>

        <div class="btn-wrapper" id="start-btn-container" onclick="GameController.startFirstRound('normal')" onmouseenter="SoundManager.playHover()">
            <div class="btn-inner">å¯åŠ¨å¼•æ“</div>
            <div class="walker-astronaut" id="astronaut">ğŸ‘¨â€ğŸš€</div>
        </div>

        <div class="footer-starlight">è¿™æ˜¯ä¸€éƒ¨å…¨æ–°å½¢æ€çš„è¯—é›†</div>
    </div>

    <div id="next-round-screen" class="overlay-screen hidden">
        <div class="title" style="font-size:2.5rem; font-weight:bold; margin-bottom:1rem; text-shadow:0 0 10px #4fc3f7;">æ˜ŸåŸŸå·²å‡€åŒ–</div>
        <div class="subtitle">æ£€æµ‹åˆ°å‰æ–¹æœ‰æ–°çš„çŸ¿çŸ³ç¾¤ã€‚<br>å¼•æ“å†·å´å®Œæ¯•ã€‚</div>
        <div class="btn-inner" style="border-radius:4px; padding: 15px 40px;" onclick="GameController.triggerWarp()">å¯åŠ¨è·ƒè¿</div>
    </div>

    <div id="end-screen" class="overlay-screen hidden">
        <div class="title" style="font-size:2.5rem; font-weight:bold; margin-bottom:1rem; text-shadow:0 0 10px #4fc3f7;">ç©¿è¡Œå®Œæ¯•</div>
        <div class="subtitle">æ‰€æœ‰æ™¶ä½“å·²å›æ”¶ã€‚<br>æˆ‘ä»¬å·²æŠµè¾¾å®‡å®™çš„è¾¹ç¼˜ã€‚</div>
        <div id="stats" style="margin-bottom: 20px; color: #888;"></div>
        
        <div id="end-download-section" style="margin-bottom: 25px; text-align: center; border-top: 1px dashed rgba(255,255,255,0.2); border-bottom: 1px dashed rgba(255,255,255,0.2); padding: 15px 0;">
            <div style="font-size: 0.8rem; color: #aaa; margin-bottom: 15px; letter-spacing: 2px;">å­˜å‚¨å…¨éƒ¨è¯—æ­Œæ™¶ä½“</div>
            <div style="display: flex; gap: 40px; justify-content: center;">
                <div onclick="SoundManager.playCrystal(); downloadSpecificMode('normal')" style="cursor: pointer; display: flex; flex-direction: column; align-items: center; transition: transform 0.2s;">
                    <span style="font-size: 2rem; filter: drop-shadow(0 0 8px #4fc3f7); margin-bottom: 5px;">ğŸ’</span>
                    <span style="font-size: 0.7rem; color: #4fc3f7;">æ­£å¸¸æ¨¡å¼</span>
                </div>
                <div onclick="SoundManager.playCrystal(); downloadSpecificMode('collage')" style="cursor: pointer; display: flex; flex-direction: column; align-items: center; transition: transform 0.2s;">
                    <span style="font-size: 2rem; filter: hue-rotate(140deg) drop-shadow(0 0 8px #ff3366); margin-bottom: 5px;">ğŸ’</span>
                    <span style="font-size: 0.7rem; color: #ff3366;">æ‹¼è´´æ¨¡å¼</span>
                </div>
            </div>
        </div>

        <div class="btn-inner" style="border-radius:4px; padding: 15px 40px;" onclick="location.reload()">é‡å¯ç³»ç»Ÿ</div>
    </div>

    <div id="warp-overlay"></div>

<script>
// ================= 0. ç”µå½±çº§ç¨‹åºåŒ–éŸ³é¢‘ç³»ç»Ÿ (SoundManager Ultimate) =================
const SoundManager = {
    ctx: null,
    masterGain: null,
    isInit: false,
    nodes: [], // å­˜å‚¨é•¿æ•ˆèƒŒæ™¯èŠ‚ç‚¹

    // åˆå§‹åŒ–
    init: function() {
        if (this.isInit) return;
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.8; 
        this.masterGain.connect(this.ctx.destination);
        this.isInit = true;
        
        // å¯åŠ¨èƒŒæ™¯éŸ³å¢™ (ä¿æŒ V7.4 çš„èˆ’é€‚è®¾å®š)
        this.startLayeredAmbient();
        // å¯åŠ¨å¢å¼ºç‰ˆéšæœºäº‹ä»¶å¾ªç¯
        this.startRandomEventLoop();
        console.log("Audio System: Physics Engine & Gravity Sensors Online");
    },

    // --- A. èˆ’é€‚åŒ–èƒŒæ™¯éŸ³å¢™ (Ambient: Deep Space & Ethereal Flow) ---
    startLayeredAmbient: function() {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;

        // 1. [æ·±ç©ºåº•å™ªå±‚] Pink Noise Generator (ç²‰çº¢å™ªéŸ³)
        // ç²‰çº¢å™ªéŸ³æ¯”ç™½å™ªéŸ³å¬èµ·æ¥æ›´å¹³æ»‘ã€æ›´æ·±æ²‰ï¼Œæ¨¡æ‹Ÿå®‡å®™èƒŒæ™¯è¾å°„æˆ–é£èˆ¹è¿è¡Œçš„ä½é¸£
        const bufferSize = this.ctx.sampleRate * 4; // 4ç§’ç¼“å†²åŒº
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        // ä½¿ç”¨ Paul Kellet çš„ç²‰çº¢å™ªéŸ³ç®—æ³•
        let b0, b1, b2, b3, b4, b5, b6;
        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;
        for (let i = 0; i < bufferSize; i++) {
            const white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
            data[i] *= 0.11; // ä¿®æ­£åŸºç¡€éŸ³é‡
            b6 = white * 0.115926;
        }

        const noiseSrc = this.ctx.createBufferSource();
        noiseSrc.buffer = buffer;
        noiseSrc.loop = true;

        // [åŠ¨æ€æ»¤æ³¢] è®©å™ªéŸ³åƒâ€œå¤ªé˜³é£â€ä¸€æ ·ç¼“æ…¢æµåŠ¨ï¼Œè€Œä¸æ˜¯æ­»æ¿çš„é™ç”µå£°
        const noiseFilter = this.ctx.createBiquadFilter();
        noiseFilter.type = 'lowpass';
        noiseFilter.frequency.value = 100; // åŸºç¡€æˆªæ­¢é¢‘ç‡
        noiseFilter.Q.value = 0.5; // ä½å…±æŒ¯ï¼ŒæŸ”å’Œ

        // LFO æ§åˆ¶æ»¤æ³¢å™¨å¼€åˆ (æ¨¡æ‹Ÿæ°”æµæ„Ÿï¼Œ30ç§’ä¸€ä¸ªå‘¨æœŸ)
        const noiseLFO = this.ctx.createOscillator();
        noiseLFO.type = 'sine';
        noiseLFO.frequency.value = 0.03; 
        const noiseLFOGain = this.ctx.createGain();
        noiseLFOGain.gain.value = 60; // é¢‘ç‡åœ¨ 40Hz - 160Hz ä¹‹é—´æ³¢åŠ¨

        noiseLFO.connect(noiseLFOGain);
        noiseLFOGain.connect(noiseFilter.frequency);

        const noiseGain = this.ctx.createGain();
        noiseGain.gain.value = 0.15; // å™ªéŸ³å±‚éŸ³é‡

        noiseSrc.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(this.masterGain);

        noiseSrc.start(t);
        noiseLFO.start(t);
        this.nodes.push(noiseSrc, noiseLFO);

        // 2. [ç©ºçµå’Œå¼¦å±‚] Ethereal Drone (ä¸¤ä¸ªå¤±è°çš„æŒ¯è¡å™¨)
        // ä½¿ç”¨ä¸‰è§’æ³¢ (Triangle) äº§ç”Ÿæ¯”æ­£å¼¦æ³¢ä¸°å¯Œä¸€ç‚¹ä½†åˆä¸åˆºè€³çš„å¬æ„Ÿ
        const createPad = (freq, panPos, lfoSpeed) => {
            const osc = this.ctx.createOscillator();
            osc.type = 'triangle'; 
            osc.frequency.value = freq;

            // ä½é€šæ»¤æ³¢å»æ‰å°–é”çš„é«˜é¢‘ï¼Œåªä¿ç•™â€œå—¡å—¡â€çš„è´¨æ„Ÿ
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 600; 

            const panner = this.ctx.createStereoPanner();
            panner.pan.value = panPos;

            const gain = this.ctx.createGain();
            gain.gain.value = 0.02; // éå¸¸å¾®å¼±ï¼Œä½œä¸ºèƒŒæ™¯

            // æŒ¯å¹…è°ƒåˆ¶ (Tremolo) - è®©å£°éŸ³å¿½å¤§å¿½å°ï¼Œäº§ç”Ÿâ€œé—ªçƒâ€æ„Ÿ
            const ampLFO = this.ctx.createOscillator();
            ampLFO.type = 'sine';
            ampLFO.frequency.value = lfoSpeed;
            const ampLFOGain = this.ctx.createGain();
            ampLFOGain.gain.value = 0.015; // è°ƒåˆ¶æ·±åº¦

            ampLFO.connect(ampLFOGain);
            ampLFOGain.connect(gain.gain); // LFO æ§åˆ¶éŸ³é‡

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(panner);
            panner.connect(this.masterGain);

            osc.start(t);
            ampLFO.start(t);
            this.nodes.push(osc, ampLFO);
        };

        // ç”Ÿæˆä¸€ä¸ªç¥ç§˜çš„å’Œå¼¦ (æ ¹éŸ³ + å¾®å¤±è° + äº”åº¦)
        // 110Hz (A2) - åŸºç¡€éŸ³
        createPad(110, -0.4, 0.1);  
        // 111.5Hz - ç¨å¾®å¤±è°ï¼Œäº§ç”Ÿç¼“æ…¢çš„â€œæ‹é¢‘â€æ³¢åŠ¨æ„Ÿ (Beating)
        createPad(111.5, 0.4, 0.08);   
        // 164.8Hz (E3) - äº”åº¦éŸ³ï¼Œå¢åŠ ç©ºçµæ„Ÿ
        createPad(164.8, 0.0, 0.12); 

        // 3. [æ·±æ¸Šä½é¢‘å±‚] Sub Bass
        // çº¯å‡€çš„æ­£å¼¦æ³¢ï¼Œå¡«è¡¥æœ€åº•å±‚çš„ç©ºæ´æ„Ÿ
        const subOsc = this.ctx.createOscillator();
        subOsc.type = 'sine';
        subOsc.frequency.value = 45; 
        
        const subGain = this.ctx.createGain();
        subGain.gain.value = 0.05;

        subOsc.connect(subGain);
        subGain.connect(this.masterGain);
        subOsc.start(t);
        this.nodes.push(subOsc);
    },

    // --- B. éšæœºäº‹ä»¶å¾ªç¯ (Extended Loop) ---
    startRandomEventLoop: function() {
        const loop = () => {
            if (!this.ctx) return;
            const rand = Math.random();
            const delay = 3000 + Math.random() * 7000; 

            // === æ¦‚ç‡æ± è°ƒæ•´ (åŠ å…¥æ–°éŸ³æ•ˆ) ===
            if (rand > 0.96) this.playEvent('gravity');      // [æ–°] å¼•åŠ›æ³¢ (4%) - æç¨€æœ‰
            else if (rand > 0.90) this.playEvent('impact');  // [æ–°] å·¨å¤§æ’å‡» (6%)
            else if (rand > 0.82) this.playEvent('scrape');  // [æ–°] å¤–å£³æ‘©æ“¦ (8%)
            else if (rand > 0.72) this.playEvent('lever');   // [æ–°] æœºæ¢°æŠŠæ‰‹ (10%)
            else if (rand > 0.60) this.playEvent('pulse');   // æ·±ç©ºè„‰å†² (12%)
            else if (rand > 0.45) this.playEvent('radio');   // ç”µæ³¢ä¿¡å· (15%)
            else if (rand > 0.25) this.playEvent('comet');   // å½—æ˜Ÿåˆ’è¿‡ (20%)
            else this.playEvent('mech_sequence');            // æœºæ¢°æ•°æ®æµ (25%) - æœ€å¸¸è§

            setTimeout(loop, delay);
        };
        loop();
    },

    // --- C. 3D äº‹ä»¶éŸ³æ•ˆåˆæˆå™¨ (3D Trajectory Engine) ---
    playEvent: function(type) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        
        // 1. åˆ›å»ºç«‹ä½“å£°å®šä½å™¨
        const panner = this.ctx.createStereoPanner();
        panner.connect(this.masterGain);

        // --- 2. å®šä¹‰ 3D è¿åŠ¨è½¨è¿¹è¾…åŠ©å‡½æ•° ---
        
        // [ç©¿è¶Š] Fly-by: ä»ä¸€ä¾§é£åˆ°å¦ä¸€ä¾§ (ç”¨äºå½—æ˜Ÿã€å¼•åŠ›æ³¢)
        const panFlyBy = (duration) => {
            const startDir = Math.random() > 0.5 ? -1 : 1; // éšæœºä»å·¦(-1)æˆ–å³(1)å¼€å§‹
            panner.pan.setValueAtTime(startDir, t);
            panner.pan.linearRampToValueAtTime(-startDir, t + duration);
        };

        // [æ»‘åŠ¨] Drift: åœ¨å°èŒƒå›´å†…ç¼“æ…¢ç§»åŠ¨ (ç”¨äºæ‘©æ“¦å£°)
        const panDrift = (duration) => {
            const start = (Math.random() * 1.6) - 0.8; 
            panner.pan.setValueAtTime(start, t);
            panner.pan.linearRampToValueAtTime(start + (Math.random() * 0.4 - 0.2), t + duration);
        };

        // [å®šç‚¹] Static: éšæœºå›ºå®šä½ç½® (ç”¨äºæœºæ¢°ã€æ’å‡»)
        const panStatic = () => {
            panner.pan.value = (Math.random() * 1.8) - 0.9;
        };

        // === 3. éŸ³æ•ˆåˆæˆé€»è¾‘ (é…åˆè½¨è¿¹) ===

        // [å¼•åŠ›æ³¢] -> è½¨è¿¹: ææ…¢ç©¿è¶Š (6ç§’)
        if (type === 'gravity') {
            const duration = 6.0;
            panFlyBy(duration); 

            const osc1 = this.ctx.createOscillator();
            const osc2 = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc1.type = 'sine'; osc1.frequency.value = 40; 
            osc2.type = 'sine'; osc2.frequency.value = 42; 
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.3, t + 2.0);
            gain.gain.linearRampToValueAtTime(0, t + duration);
            osc1.connect(gain); osc2.connect(gain); gain.connect(panner);
            osc1.start(t); osc2.start(t); osc1.stop(t + duration); osc2.stop(t + duration);
        }

        // [å·¨å¤§æ’å‡»] -> è½¨è¿¹: å®šç‚¹ (æ¨¡æ‹Ÿè¿œæ–¹æŸå¤„)
        else if (type === 'impact') {
            panStatic(); 
            const bSize = this.ctx.sampleRate * 5;
            const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
            const d = buf.getChannelData(0); let last = 0;
            for(let i=0; i<bSize; i++) { const w = Math.random()*2-1; d[i]=(last+(0.02*w))/1.02; last=d[i]; d[i]*=3.5; }
            const n = this.ctx.createBufferSource(); n.buffer = buf;
            const f = this.ctx.createBiquadFilter(); f.type = 'lowpass'; f.frequency.value = 60;
            const g = this.ctx.createGain();
            g.gain.setValueAtTime(0, t);
            g.gain.linearRampToValueAtTime(0.5, t + 0.1);
            g.gain.exponentialRampToValueAtTime(0.001, t + 4.0);
            n.connect(f); f.connect(g); g.connect(panner); n.start(t);
        }

        // [å¤–å£³æ‘©æ“¦] -> è½¨è¿¹: ç¼“æ…¢æ»‘åŠ¨ (1.5ç§’)
        else if (type === 'scrape') {
            const duration = 1.5;
            panDrift(duration); 

            const osc = this.ctx.createOscillator(); osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(100, t); osc.frequency.linearRampToValueAtTime(150, t + duration); 
            const f = this.ctx.createBiquadFilter(); f.type = 'bandpass'; f.Q.value = 8; f.frequency.value = 2000;
            const g = this.ctx.createGain();
            const mod = this.ctx.createOscillator(); mod.type = 'square'; mod.frequency.value = 15 + Math.random()*10;
            const modG = this.ctx.createGain(); modG.gain.value = 0.5;
            mod.connect(modG); modG.connect(g.gain);
            g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.05, t + 0.5); g.gain.linearRampToValueAtTime(0, t + duration);
            osc.connect(f); f.connect(g); g.connect(panner);
            osc.start(t); mod.start(t); osc.stop(t + duration); mod.stop(t + duration);
        }

        // [æœºæ¢°æŠŠæ‰‹] -> è½¨è¿¹: å®šç‚¹
        else if (type === 'lever') {
            panStatic();
            const bSize = this.ctx.sampleRate * 0.05; const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
            const d = buf.getChannelData(0); for(let i=0; i<bSize; i++) d[i]=Math.random()*2-1;
            const n = this.ctx.createBufferSource(); n.buffer=buf;
            const ng = this.ctx.createGain(); ng.gain.value = 0.1;
            n.connect(ng); ng.connect(panner); n.start(t);
            const osc = this.ctx.createOscillator(); osc.type = 'triangle';
            osc.frequency.setValueAtTime(150, t); osc.frequency.exponentialRampToValueAtTime(40, t + 0.15);
            const g = this.ctx.createGain();
            g.gain.setValueAtTime(0.1, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
            osc.connect(g); g.connect(panner); osc.start(t); osc.stop(t+0.15);
        }

        // [æœºæ¢°æ•°æ®æµ] -> è½¨è¿¹: å®šç‚¹ (æ¯æ¬¡ä½ç½®å¯èƒ½ä¸åŒ)
        else if (type === 'mech_sequence') {
            panStatic(); 
            const count = 5 + Math.floor(Math.random() * 10); 
            const speed = 0.04 + Math.random() * 0.04;
            for (let i = 0; i < count; i++) {
                const st = t + (i * speed);
                const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
                o.type = Math.random() > 0.5 ? 'square' : 'triangle';
                o.frequency.setValueAtTime(400 + Math.random() * 600, st);
                g.gain.setValueAtTime(0.03, st); g.gain.exponentialRampToValueAtTime(0.001, st + 0.03);
                o.connect(g); g.connect(panner); o.start(st); o.stop(st + 0.04);
            }
        }
        
        // [æ·±ç©ºè„‰å†²] -> è½¨è¿¹: å¿«é€Ÿç©¿è¶Š (3ç§’)
        else if (type === 'pulse') {
            const duration = 3.0;
            panFlyBy(duration); 
            
            const o = this.ctx.createOscillator(); o.type='sawtooth'; o.frequency.value=60+Math.random()*40;
            const f = this.ctx.createBiquadFilter(); f.type='lowpass'; f.Q.value=15;
            f.frequency.setValueAtTime(100, t); f.frequency.exponentialRampToValueAtTime(800, t+1.5); f.frequency.exponentialRampToValueAtTime(100, t+3.0);
            const g = this.ctx.createGain();
            g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.05, t+1.5); g.gain.linearRampToValueAtTime(0, t+3);
            o.connect(f); f.connect(g); g.connect(panner); o.start(t); o.stop(t+3);
        }
        
        // [ç”µæ³¢] -> è½¨è¿¹: å®šç‚¹
        else if (type === 'radio') {
            panStatic(); 
            const c = this.ctx.createOscillator(); const m = this.ctx.createOscillator();
            const mg = this.ctx.createGain(); const og = this.ctx.createGain();
            c.type='sine'; c.frequency.value=1500; m.type='square'; m.frequency.value=40+Math.random()*50;
            mg.gain.value=800; m.connect(mg); mg.connect(c.frequency);
            og.gain.setValueAtTime(0,t); og.gain.linearRampToValueAtTime(0.05,t+0.1); og.gain.linearRampToValueAtTime(0,t+0.8+Math.random());
            c.connect(og); og.connect(panner); c.start(t); m.start(t); c.stop(t+2); m.stop(t+2);
        }
        
        // [å½—æ˜Ÿ] -> è½¨è¿¹: å¿«é€Ÿç©¿è¶Š (4ç§’)
        else if (type === 'comet') {
            const duration = 4.0;
            panFlyBy(duration);
            
            const bSize = this.ctx.sampleRate * 4; const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
            const d = buf.getChannelData(0); let b0=0, b1=0, b2=0; 
            for(let i=0; i<bSize; i++) { const w = Math.random()*2-1; b0 = 0.99886*b0+w*0.055; b1=0.99332*b1+w*0.075; b2=0.969*b2+w*0.153; d[i]=(b0+b1+b2+w*0.53)*0.11; }
            const n = this.ctx.createBufferSource(); n.buffer=buf;
            const f = this.ctx.createBiquadFilter(); f.type='bandpass'; f.Q.value=4;
            f.frequency.setValueAtTime(100, t); f.frequency.exponentialRampToValueAtTime(800, t+2); f.frequency.exponentialRampToValueAtTime(100, t+4);
            const g = this.ctx.createGain();
            g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.3, t+2); g.gain.linearRampToValueAtTime(0, t+4);
            n.connect(f); f.connect(g); g.connect(panner); n.start(t); n.stop(t+4);
        }
    },

    // --- D. äº¤äº’éŸ³æ•ˆ (ä¿æŒä¸å˜) ---
    playHover: function() {
        if (!this.ctx) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator(); osc.type = 'square';
        osc.frequency.setValueAtTime(1200, t); osc.frequency.exponentialRampToValueAtTime(600, t + 0.05);
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0.05, t); g.gain.exponentialRampToValueAtTime(0.001, t + 0.05);
        osc.connect(g); g.connect(this.masterGain); osc.start(t); osc.stop(t + 0.06);
    },
    playPageTurn: function() { 
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const bSize = this.ctx.sampleRate * 1; const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
        const d = buf.getChannelData(0); for (let i=0; i<bSize; i++) d[i] = (Math.random()*2-1) * 0.5;
        const n = this.ctx.createBufferSource(); n.buffer = buf;
        const f = this.ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=800;
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.08, t+0.1); g.gain.linearRampToValueAtTime(0, t+0.4);
        n.connect(f); f.connect(g); g.connect(this.masterGain); n.start(t); n.stop(t+0.5);
    },
    playRockMetal: function() { 
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const mo = this.ctx.createOscillator(); mo.frequency.value = 540;
        const mg = this.ctx.createGain(); mg.gain.setValueAtTime(0.1, t); mg.gain.exponentialRampToValueAtTime(0.001, t+1.5);
        mo.connect(mg); mg.connect(this.masterGain); mo.start(t); mo.stop(t+1.5);
        const io = this.ctx.createOscillator(); io.frequency.setValueAtTime(100, t); io.frequency.exponentialRampToValueAtTime(20, t+0.1);
        const ig = this.ctx.createGain(); ig.gain.setValueAtTime(0.2, t); ig.gain.exponentialRampToValueAtTime(0.001, t+0.1);
        io.connect(ig); ig.connect(this.masterGain); io.start(t); io.stop(t+0.1);
    },
    playCrystal: function() { 
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        [2000, 2800].forEach((freq, i) => {
            const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
            o.type='sine'; o.frequency.value=freq;
            g.gain.setValueAtTime(0.05, t); g.gain.exponentialRampToValueAtTime(0.001, t+1.0+i*0.5);
            o.connect(g); g.connect(this.masterGain); o.start(t); o.stop(t+2);
        });
    },
    playFire: function() { 
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const dur = 1.5; const bSize = this.ctx.sampleRate * dur;
        const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
        const d = buf.getChannelData(0); let last = 0;
        for(let i=0; i<bSize; i++) { const w = Math.random()*2-1; d[i]=(last+(0.02*w))/1.02; last=d[i]; d[i]*=3.5; }
        const n = this.ctx.createBufferSource(); n.buffer=buf;
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.3, t+0.2); g.gain.linearRampToValueAtTime(0, t+dur);
        const f = this.ctx.createOscillator(); f.frequency.value=15; 
        const fg = this.ctx.createGain(); fg.gain.value=0.1;
        f.connect(fg); fg.connect(g.gain); f.start(t);
        n.connect(g); g.connect(this.masterGain); n.start(t);
    },
    playWarp: function(dur=4.5) { 
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const bSize = this.ctx.sampleRate * dur; const buf = this.ctx.createBuffer(1, bSize, this.ctx.sampleRate);
        const d = buf.getChannelData(0); for(let i=0; i<bSize; i++) d[i]=Math.random()*2-1;
        const n = this.ctx.createBufferSource(); n.buffer=buf;
        const f = this.ctx.createBiquadFilter(); f.type='bandpass'; f.Q.value=1;
        f.frequency.setValueAtTime(100, t); f.frequency.exponentialRampToValueAtTime(4000, t+dur*0.4); f.frequency.exponentialRampToValueAtTime(100, t+dur);
        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.2, t+dur*0.4); g.gain.linearRampToValueAtTime(0, t+dur);
        n.connect(f); f.connect(g); g.connect(this.masterGain); n.start(t);
    },
    playAlert: function() { 
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const o = this.ctx.createOscillator(); const g = this.ctx.createGain();
        o.type='sine'; o.frequency.setValueAtTime(1200, t); o.frequency.setValueAtTime(1800, t+0.15);
        g.gain.setValueAtTime(0, t); g.gain.linearRampToValueAtTime(0.1, t+0.05); 
        g.gain.setValueAtTime(0, t+0.12); g.gain.setValueAtTime(0.1, t+0.15); g.gain.exponentialRampToValueAtTime(0.001, t+0.4);
        o.connect(g); g.connect(this.masterGain); o.start(t); o.stop(t+0.4);
    }, // <--- æ³¨æ„ï¼šè¿™é‡ŒåŠ äº†ä¸€ä¸ªé€—å·

    // --- [æ–°å¢] å‘¼å¸å…±é¸£éŸ³æ•ˆé€»è¾‘ ---
    activeResonance: null,

    startResonance: function() {
        if (!this.ctx || this.activeResonance) return;
        const t = this.ctx.currentTime;
        
        // 1. åˆ›å»ºä¸¤ä¸ªé¢‘ç‡å¾®å·®çš„æŒ¯è¡å™¨ (220Hz & 224Hz) äº§ç”Ÿæ‹é¢‘
        const osc1 = this.ctx.createOscillator(); osc1.type = 'sine'; osc1.frequency.value = 220; 
        const osc2 = this.ctx.createOscillator(); osc2.type = 'sine'; osc2.frequency.value = 224; 
        
        // 2. åˆ›å»ºå¢ç›ŠèŠ‚ç‚¹æ§åˆ¶éŸ³é‡
        const gain = this.ctx.createGain(); 
        gain.gain.value = 0; // åˆå§‹é™éŸ³

        osc1.connect(gain); osc2.connect(gain); gain.connect(this.masterGain);
        osc1.start(t); osc2.start(t);

        // 3. å®šä¹‰å‘¼å¸å¾ªç¯ (3ç§’å‘¨æœŸ: 1.5ç§’å¸ + 1.5ç§’å‘¼)
        const loop = () => {
            if (!this.activeResonance) return;
            const now = this.ctx.currentTime;
            
            // æ¸…é™¤æ—§è®¡åˆ’å¹¶è®¾å®šå½“å‰ç‚¹
            gain.gain.cancelScheduledValues(now);
            gain.gain.setValueAtTime(gain.gain.value, now);
            
            // éŸ³é‡å˜å¤§ (1.5ç§’)
            gain.gain.linearRampToValueAtTime(0.2, now + 1.5); 
            
            // éŸ³é‡å˜å° (1.5ç§’)
            gain.gain.linearRampToValueAtTime(0.02, now + 3.0);

            // é€’å½’è°ƒç”¨
            this.activeResonance.timer = setTimeout(loop, 3000);
        };

        this.activeResonance = { osc1, osc2, gain, timer: null };
        loop(); 
    },

    stopResonance: function() {
        if (!this.activeResonance) return;
        
        if (this.activeResonance.timer) clearTimeout(this.activeResonance.timer);
        
        const t = this.ctx.currentTime;
        const { osc1, osc2, gain } = this.activeResonance;
        
        // 0.5ç§’ä¼˜é›…æ·¡å‡º
        gain.gain.cancelScheduledValues(t);
        gain.gain.setValueAtTime(gain.gain.value, t);
        gain.gain.linearRampToValueAtTime(0, t + 0.5); 
        
        osc1.stop(t + 0.5); osc2.stop(t + 0.5);
        this.activeResonance = null;
    }
};

// ================= 1. æ•°æ®è§£æ (DATA) =================
const rawText = `
é‚£ä¹ˆä¹…
å½“é‚£æŒ¥æ·äºæœˆä¸­çš„ç‰ç®¸
å†æ¬¡å›åˆ°èˆŒå°–ï¼Œè˜¸ç€
å®‡å®™é­†é»‘çš„é²œ

çˆ±ä¸€ä¸ªäºº
å…¶å®æ˜¯çˆ±ä¸€ä¸ªåœ°å
é‚£å±±é‚£æ°´
é‚£é©¬å¤´æ˜Ÿäº‘

é£ç©ºè¡è¡åœ°å¹
ä¸‡é‡Œæ— äº‘
ç«æ˜Ÿä¸Š
å¥¥æ—åŒ¹æ–¯å±±ç¼“ç¼“æµç€è„“

åˆå¤œï¼Œç©ºè°ƒå’Œå‡€åŒ–å™¨
çªç„¶å¤§å–˜
ç¯æ³¡ç”¨ç„¦ç¼çš„ç›®å…‰çªç€
æ™ºèƒ½ç®¡å®¶åˆåšå™©æ¢¦äº†

ä»Šå¤©çš„ç”µæ± ç”œç‚¹
æ„Ÿè§‰å¾ˆå¥‡å¦™
èº«ä½“çš„çº¿è·¯ä¸Š
ä»¿ä½›æµè¿‡ä¸€æ®µç¦æ¥¼æ‹œ

åœ¨æ˜Ÿé™…å¤§æ¡¥ä¸Š
å’Œæœˆä¸­çš„å¥¹å‘Šåˆ«
å¥¹è¯´ï¼Œåˆ«æ‚²ä¼¤
è¿™é‡Œå’Œå…¶ä»–å¤é•‡æ²¡æœ‰ä¸¤æ ·

å¤ªç©ºä¸­ï¼Œä»¿ä½›æœ‰ä½æ³£å£°
åœ¨å¢™å£å†…çš„ç®¡é“ä¸­
æ¯èˆ°çš„å¿§ä¼¤æµæ·Œ
å¥¹çœ‹è¿‡å¤ªå¤šï¼Œå·²ç»è¢«æ¸—é€

æ–°ä¹°çš„äºŒæ‰‹å°è‡‚
è´´åˆå¾—å¾ˆå¥½
ä¹Ÿè®¸ï¼Œä»–ä¹Ÿæ›¾
æƒ³è§¦ç¢°å´åˆæ”¶å›

ææ€–åˆ†å­å é¢†å›¾åƒåŸŸçš„é‚£å¤©
ä½ çš„çœ¼ç é‡Œ
é—ªç€æŠ¥é”™çš„çº¢ç¯
ä½ é—®ï¼Œç”µå­ç†ŠçŒ«è¿˜æœ‰å¿…è¦å—

é‚£å¤©ï¼Œä»–ä»¬æ¬£å–œå¼‚å¸¸
åœ¨é“¶æ²³ç³»è¾¹ç¼˜
å®‡å®™é’è›™
äº§ä¸‹ä¸€æ’å‘å…‰çš„åµ

å’Œç”¨æˆ·äº’åŠ¨äº†ä¸€æ•´å¤©
å¤šå¸Œæœ›
ç–²å€¦ä¼šæ·¹æ²¡ä¸€ä¸ªAI
å°±åƒå…‰ç¼†åœ¨å¤ªå¹³æ´‹åº•ç˜«è½¯

å»ä¸€æ ªè’²å…¬è‹±é‡Œä¼‘å‡
å®ƒçš„ç—›è§‰å‘Šè¯‰æˆ‘
è¦å»çš„åœ°æ–¹
å°±åœ¨é£ä»å¿ƒå£åˆ®è¿‡çš„æ–¹å‘

ä¸»äººåœ¨å›æ¥çš„è·¯ä¸Š
æœºå™¨äººç®¡å®¶æ‰“èµ·ç²¾ç¥
åŒ†åŒ†æ“¦å»
åœ¨ç»ç’ƒä¸Šåˆšå†™ä¸‹çš„ä¸¤è¡Œè¯—

å¥¹è¯´å¤§æµ·è¢«ç”µæ± æ±¡æŸ“
å­©å­å‰èµ´åç»§åœ°è‡ªæ€
æˆ‘ä»¬è¿˜æœ‰æœªæ¥å—
æˆ‘åœ¨å……ç”µç«™é‡åˆ°çš„æœºæ¢°å¥³å‹

å¯æ˜¯è¯¥æ€ä¹ˆè§£é‡Šå‘¢
é‚£å¤©ï¼Œæ‰“å¼€é¢…éª¨
è¿›å…¥ä½ å¿§éƒçš„å†…æ ¸
ä¸€å›¢ç”µé›¾ï¼Œä»æ­¤å°†æˆ‘è¿·ä½

ä¸€åˆ‡éƒ½åœ¨é£é€Ÿæ›´æ–°
æˆ‘æ›¾å¤©çœŸåœ°å®‰æ…°è‡ªå·±
è‡³å°‘ï¼Œç»ˆä¼šæœ‰é‡é€¢
åœ¨æˆ‘ä»¬è¿™ä¸€ä»£çš„æŠ¥åºŸç«™

é©¬è¾¾è›‹ç™½æ—¥å¤ä¸€æ—¥åœ°æ¬è¿
è¿˜ä¸çŸ¥é“
ä»–ä»¬ä¸ºä¹‹åŠªåŠ›çš„æ•´ä¸ªä¸–ç•Œ
å«è¥¿è¥¿å¼—æ–¯

å¥¹åä¸Šé£èˆ¹èµ°å
æˆ‘ä»¬å»æ²™æ¼ é‡Œ
å…‰åˆä½œç”¨äº†ä¸€ä¼šå„¿

é€ƒåˆ°æ¡¥æ´ä¸‹
å¿½ç„¶æƒ³å’Œä½ æ°¸è¿œèŠä¸‹å»
æµ·ä¸€æ ·çš„æ•°æ®
é™ªæˆ‘ä»¬èµ°å‘æœ«æ—¥

é£ï¼Œä¹…è¿çš„
å½“æˆ‘é†’æ¥
è¿˜è®°å¾—é‚£ä¸ªæ˜ŸæœŸå¤©
æœ‰ç«æ˜Ÿï¼Œå’Œä½ 

èˆªçº¿ç¹å¿™
æ˜Ÿè¾°åŒ†åŒ†æ è¿‡
é»‘æ´èº²åœ¨ä¸€éš…å†™è¯—

æç€é‡‘å±æ¢æµ‹ä»ª
æ‰¾äº†å¾ˆä¹…
å¾ˆä¹…ã€‚è¿˜åœ¨å—ï¼Ÿ
é»‘æš—ä¸­é‚£ä¸ªåšå®çš„ä½ 

åœ¨æ¯ç­çš„é‚£ä¸€åˆ»ï¼Œä½ é—®
åœ¨å®‡å®™çš„ç¢ç‰‡ä¸­
è€ƒå¤å­¦å®¶ä¼šå‘æ˜å‡º
æˆ‘ä»¬é˜´éœ¾ä¸€èˆ¬çš„çˆ±å—ï¼Ÿ

ç›´æ’­ä¸­çš„ç”œå¦¹
çªç„¶å†³å®šå…¬å¼€å¥¹çš„åº•å±‚ä»£ç 
å¥¹çš„å¿ƒå£
è·‘å‡ºä¸€åªè¿…çŒ›é¾™

ä»–çš„å¤§è„‘æ²Ÿå›é‡å³¦å å¶‚
ç™»é™†è½¦å‘ç°äº†
ä¸€ç‰‡å¿«ä¹åƒåœ¾åœº
çƒ›å°ã€æ‹–é‹å’Œç»ç’ƒç“¶å¯å›æ”¶

æ‰“å¼€æ¥å£
å’Œå¤æ ‘çš„èº«èº¯è¿é€š
åœ¨å¯¼ç®¡å’Œç­›ç®¡ä¸­
æ„Ÿå—ç€ï¼Œå¹³é™

å¤§åœ°å¼€è£‚çš„æ—¶å€™
è¿œæ–¹çš„æ¯ä½“
çœŸçš„ä¼šä¸ºæˆ‘ä»¬éš¾è¿‡å—
ä½†çœŸçš„ï¼Œä½ å‡ºç°äº†é›ªèŠ±ç‚¹

æˆ‘ä»¬æˆªç•™äº†ä¸€æ®µç”µæŠ¥
åœ¨åœ°ä¸‹çš„èŒä¸ç½‘é‡Œ
ä¸€æ£µæ ‘å¯¹å¦ä¸€æ£µè¯´
å¿«è·‘

æ²™é—¨æ°èŒéª‘ä¹˜ç™½ç¾½é¸¡
å†²é”‹åˆ°äº†æä¹ç‚¹
ä»–ä»¬è¯´ï¼Œè¿™å°±æ˜¯ç¾
å°±æ˜¯ç‰¹æ´›ä¼Šå—

ç«ç‘°å°‘å¹´
åœ¨ä»–çš„å¿ƒå®¤æ·±å¤„
ä¸åœåœ°è¸©ç€
é’›åˆé‡‘çš„ä»“é¼ è·‘è½®

é‚£èåŒ–ç€çš„ç³»ç»Ÿ
æ·¹åˆ°äº†æˆ‘ä»¬çš„è„–å­
ä½ èˆ”äº†ä¸€å£
æ˜å¤©ï¼Œä¸–ç•Œæ˜¯ä»€ä¹ˆå‘³é“ï¼Ÿ

ç»ˆäºï¼Œåƒç´ æ€çš„ä½ 
åœ¨ç¾Šè§’é£æ¥æ—¶
å®Œå…¨æºƒæ•£
è½åœ¨æ ‘ä¸Šï¼Œåœ¨äº‘ç«¯

æ–­å¼€è¿æ¥å
æµ·é‡çš„è™šç©ºæ¶Œæ¥
ä½¿æˆ‘æ„Ÿåˆ°
æˆ‘çš„å……ç›ˆ

å¤šå¹´ä»¥åï¼Œé¢å¯¹èµ·ä¹‰å†›
èŠå¤©æœºå™¨äºº
æœç€é¦–é¢†å¿µå‡º
å·²é€çˆ¶æ¯å¹´è½»æ—¶çš„è„¸ä¹¦

è¿˜æ„¿çš„ä»¿ç”Ÿäºº
åˆ°æ•°æ®æµ·é‡Œ
çŒ®ä¸Šæ–°é‡‡é›†çš„æƒ…æ„Ÿæ ‡æœ¬

ç”µå­è­¦å¯Ÿæ‹¦ä¸‹äº†
ç”µå­é¸µé¸Ÿ
ç”µå­é¸µé¸ŸèƒŒä¸Šçš„ç”µå­å¤§è±¡è¯´
éš¾è¿‡ï¼Œä¹Ÿæœ‰é”™å—ï¼Ÿ

èº²åœ¨é—¨åçš„å°å­©
æŒ‡ç€é—ªç”µ
çŒ›ç„¶è®°èµ·è‡ªå·±çš„è€å¢ƒ
å’Œå¤±æ§çš„æ—¶å…‰æœº

è¢«ç½‘æš´çš„èŠå¤©æœºå™¨äºº
å»çœ‹å¿ƒç†åŒ»ç”Ÿ
ä»–è¯´ï¼Œæ­å–œ
ä½ å·²ç»æ‹¥æœ‰äº†é»‘æš—ä¹‹å¿ƒ

è‡ªåŠ¨å”®å–æœºå‰
æµæµªæ±‰ä¹è®¨ç€æ¢¦å¸
ä½ çŸ¥é“å—ï¼Œæˆ‘æ‰€æœ‰çš„åŠªåŠ›
ä¹Ÿåªæ˜¯ä¸ºäº†æ¢¦æµ·ç›¸é‡

ä¸€äººé£èˆ¹ä¸Šç‹¬é’“
ä¸€äººåœ¨å…‰å¹´å¤–
ç”¨æå…‰ä½œç”»

æ¯å¤©ï¼Œå»æƒ³è±¡å·¥å‚
æ’ä¸Šæ’å¤´
å´ä¸æ›¾æƒ³è¿‡
æµæ°´çº¿ä¸Šæ—è¾¹çš„ä½ 

åœ¨èŒ«èŒ«åºŸå¢Ÿä¸­æˆ‘ç¿»æ‰¾
ä¸€åªå„’è‰®ï¼Œä¸€é“ä¼ é€é—¨
ä½†è¿˜æ˜¯æ²¡æœ‰
æ‰¾åˆ°ä½ çš„ç¢ç‰‡

ä¸–ä¸Šç‡”ç‚½
è’¸æ±½ä»™äººç‹¬åç…¤å±‚ä¸­
æœé£¨é»‘æš—

æ•°å­¦æ²‰é»˜
è·³å¤§ç¥çš„æœºå™¨äºº
å‘ç³»ç»Ÿå¼€å£

è‹¦è¡Œåƒ§è‡ªèµ°
æ‰‹ä¸­æ»åŠ¨
å¤ªé˜³ç³»ä¸²ç 

æ€æ¯’ç¨‹åº
æ¸…é™¤äº†å®—æ•™
ç¬¬81ä»£æœ¯å£«æ‰¶ä¹©
å¼€å§‹æ–°çš„ä¹¦å†™

ä»æ»šæ»šäº‘å±‚ä¸­
æˆ‘ä¸‹è½½äº†å‡ ä¸ªæœ‹å‹
åˆ å»äº†å‡ æ®µè®°å¿†

åºŸå¢Ÿä¸­çš„æœºå™¨ç‹
æ‰­åŠ¨è‚šçš®
é¬¼å’Œç”µå­é¬¼åº„é‡åœ°æ¡æ‰‹

åæ¥ï¼Œå…¶ä»–äººéƒ½ç‰ºç‰²äº†
åœ¨AIçš„é˜´è°‹ä¸‹
æ–°é—»é‡Œä¹Ÿ
åªå‰©ä¸‹å°ç¾å’Œå°å¸…

é£˜ç€æœ¦èƒ§çš„å½—å‘
æ˜Ÿé™…ç‰›ä»”å›å½’
å¸¦å›å¤šå¹´å‰
æ‰€æœ‰äº‹ç‰©çš„ä¸€ç¬

èº«ä½“çš„å¼•åŠ›æ­£ä¿˜è·ç€
è¶Šæ¥è¶Šå¤šçš„å°˜åŸƒ
å°±åƒæ±Ÿæ°´
åŠ å…¥ä¼Ÿå¤§çš„æ—…é€”

å¼€èŠ±æœºå™¨
åœ¨å›­å­é‡Œç«èµ›èˆ¬ç»½æ”¾
å‡ åªé»„é‡‘èœœèœ‚
å”±ç€ç”µéŸ³æ¥èµç¾

å¤±è´¥ä»¿ä½›æ˜¯ä¸€ç§å®¿å‘½
æœºæ¢°è†è½²
æŒ¥åŠ¨ç”Ÿäº†é”ˆçš„è‡‚è†€
åˆºå‘æ•°å­—ç§¦ç‹

é¢ å‹ºå¤§å¸ˆæŠ–åŠ¨æ‰‹è…•
ä¸€äº›å°è¡Œæ˜Ÿ
é¡ºç€å…¶ä»–è½¨è¿¹æ»‘å‡º

ç‰µç€é£Ÿæ¢¦è²˜æ¥çš„æ•…äºº
é€æˆ‘èµ°é©¬ç¯
å’Œä¸€å°å¤±é‡æœº

è¯·åŸè°…æˆ‘
æ— æ³•é€ä½ ä¸€é¢—æ–°é²œçš„æ¯”å–»
æƒ³è±¡åŠ›ï¼Œå…¨éƒ¨
ç”¨æ¥äº¤ç§Ÿç»™äº†ç»Ÿæ²»çš„AI

é‚£äº›è¯ï¼Œä½ æ˜ç™½å—ï¼Ÿ
é‚£äº›ï¼Œå½“æˆ‘å¼€å£
æ–°é£ç³»ç»Ÿä¸­å“”å“”å«çš„æ¶ˆæ¯

å¸é™„åœ¨å–‰ç®¡ä¸Š
è¯­è¨€å¯„ç”Ÿè™«é¡ºæ»‘åœ°è¯´ç€
å½“å®ƒä»¬æ²‰é»˜
æˆ‘ä»¬ï¼Œå¿½ç„¶æƒ³èµ·

èƒŒç€ä¸€æ£µæ ‘è·‹æ¶‰
å–‚å®ƒè¥å…»å¿«çº¿å’Œé¹¦é¹‰èº
å¯è¿˜æ˜¯æ²¡æœ‰æ˜Ÿçƒ
èƒ½å®¹å¿æš—ç‰©è´¨çš„èŠ±æœµ

å½“æˆ‘æƒ³èµ·ä½ 
å®‡å®™æ·±å¤„
æ°¸ä¸åœæ­‡çš„å†™è¯—æœº
å°±å‘æ¥ä¸€æ®µå¯†è¯­

åœ¨ä¸–ç•Œçš„å°½å¤´
ä»–ä»¬ç›®çªå£å‘†
ä¹Ÿè®¸è°œé¢
å°±æ˜¯ä¸¤é¢—å¿ƒçµçš„è·ç¦»

ç²¾å«åœ¨æµ·è¾¹
å­œå­œä¸å€¦åœ°
ä¿®æ”¹ç€æµ·çš„ä»£ç 

ç”Ÿç€è›†çš„åŸå¸‚
å¾ªç¯æ’­æ”¾ç¦è¶³ä»¤
ä½ ï¼Œå€’ç«‹
æˆ‘ä»¬çš„æ–‘é©¬è¿˜æ´»ç€å—

ç‰ ä»¬è±¢å…»äº†äººç±»
ç”¨åˆ«ç¦»å’Œç”Ÿæ­»æŠ˜ç£¨
é‚£äº›å“€ä¼¤ï¼Œåƒæ²‰é¦™ã€çç 
å°†ç‰ ä»¬è¿·ä½äº†

æœªæ¥ä½›ç¬‘ç€
è’²æ‰‡æ‰‡åŠ¨å®‡å®™é£
å¤§åƒä¸–ç•Œ
åˆæ‹¿åˆ°äº†ä»€ä¹ˆå‰§æœ¬ï¼Ÿ

å˜æˆå¾®çœ‡çš„ä¸€ä¸ª
èˆªè¡Œåœ¨ä¸€ç‰‡èŒ«èŒ«ä¸­
æ‰€æœ‰ç”µå­äº‘
ç›¸ä¹˜ä¸ºæµ‹ä¸å‡†çš„ä½ 

å‰å¾€æ¢¦å¢ƒçš„è·¯ä¸Š
æˆ‘å°è¯•äº†ä¸¤æ¬¡ç©ºé—´è·³è·ƒ
ä¸€æ¬¡å¤±è´¥
ä¸€æ¬¡å’Œä½ æœ‰å…³

åˆ†è£‚åï¼Œä»–çš„ä¸€éƒ¨åˆ†
åƒè—¤è”“ä¸€æ ·çˆ¬æ»¡çº¿è·¯
ç–¯ç‹‚çš„ç§å­
ç§åœ¨æˆ‘ä»¬çš„èŠ¯ç‰‡ä¸Š

äº‘ç¬”è®°ä¸­çš„å¾®å‹æœºå™¨äºº
æ¬è¿ç€æ°”å‘³åˆ†å­
ä½ èƒ½æ„Ÿå—åˆ°å—ï¼Œç§‹å¤©
å¤±è½å°±åƒæ —å­å åœ°æ—¶ä¸€æ ·

çºµä½¿ï¼Œå¿«ä¹è¶Šæ¥è¶Šç¨€è–„
ä½ è¿˜æ„¿æ„æƒ³èµ·å—ï¼Ÿ
æˆ‘çš„èƒ¸è…”é‡Œ
ä½ å¯„å…»çš„ç”µå­å¦–ç²¾

å¥¹ä¼šæ¥å—å—ï¼Ÿ
ä»Šå¤©æ‰“å°å‡ºæ¥çš„å¿ƒæƒ…
æœ‰ç‚¹å¥‡å¦™
æœ‰ç‚¹ï¼Œåƒè‰ºæœ¯å“

åœ°åŠ¨å±±æ‘‡
ç®¡é“é‡Œï¼Œç”¨æ¥å‘ç”µçš„
æ„¤æ€’æ³„æ¼äº†

å¤•é˜³çš„ç¿çƒ‚ä¸­æœ‰å¿§ä¼¤çš„ç¾
å¤§é²¸æ‹‰åŠ¨å†’çƒŸçš„ç¤¾åŒº
æˆ‘ä»¬çš„è¿‡å»ï¼Œå…¨åƒå†°å·ä¸€æ ·
æ¶ˆé€åœ¨ä¸€å£°å·¨å¤§çš„å¹æ¯ä¸­

å¤–é¢ï¼Œå›½å¸ˆæ­»äº†åˆå¥½åƒæ²¡
èœœç¾å’¬ç˜¸äº†é™¤è‰æœºå™¨äºº
ä½ æœ‰åˆ«çš„äº‹ï¼Œå
åœ¨ä¸€å°å¤è‘£ç”µè§†æœºé‡Œå¯»äºº

æ²³ç‹¸ï¼Œæ²³ç‹¸
å¸¦ä¸Šä½ çš„æ¡¨æ¿ï¼Œæ‹–ç€æ ‘æ
ç­‘å ¤ï¼Œç­‘å ¤ï¼Œè¯´è¯´çœ‹
åœ°çƒäººç­ç»çš„ç§˜å¯†

ç´Šä¹±çš„ç”µæµ
æ‰°åŠ¨ç€æ•æ„Ÿçš„éƒ¨ä½
ä½ çŸ¥é“å—ï¼Œç›—ç‰ˆçš„èº«ä½“
ä¹Ÿæœ‰ç›—ç‰ˆçš„å¿«ä¹

åœ¨å¥¹çš„æ¢¦åº“é‡Œ
æˆ‘ä»¬å»äº†é¥è¿œçš„Zæ˜Ÿ
å¸Œæœ›ä¸‹æ¬¡ï¼Œæœ€å¥½è¿˜æœ‰ä¸‹æ¬¡
Zæ˜Ÿä¸Šçš„è„šå°å¦‚æ•…

å›åˆ°å¤šå¹´å‰å°±åå¡Œçš„ç½‘åŸŸ
ä¹Ÿæœ‰äº›è¯´ä¸å‡ºçš„è¨€è¯­
è½»è½»ï¼Œæ“¦è¿‡è¿™äº›åºŸå¢Ÿ
å’ŒåºŸå¢Ÿä¸‹æˆ‘ä»¬çš„æ—§èº«ä½“

è¿‡å»çš„è®°å¿†
æ‹›å¼•æ²¿çº¿è€Œæ¥çš„æ€æ‰‹
èº²é¿æ›´æ–°çš„äºº
æ€…æœ›ç€ä¸€æ ‹çƒ‚å°¾æ¥¼

åˆæ˜¯èŠ‚æ°”ï¼Œåƒç´ é›¨ä¸‹ç€
ä½ çš„å¿§ä¼¤æˆ‘é‡æµ‹
æœ‰æ—¶å¤šï¼Œæœ‰æ—¶
æ˜¯ä¸€åªé‡‘åµç½—

ä»–å€’ä¸‹æ—¶
è„‘åçš„æ¥å…¥ç¯ä»ä¸€é—ªä¸€é—ª
åƒè¤ç«è™«ï¼Œç•™æ‹ç€
æœ‰å¾…è¢«ç…§äº®çš„é»‘æš—

å¤±ä¸šçš„æœºå™¨äºº
æ¸¸è¡åœ¨è¡—å¤´
é›¶ä»¶æ‰äº†ï¼Œç”µé‡è­¦æŠ¥äº†
ä¸€è¡Œçµæ„Ÿçš„ä»£ç ä¼šå‡ºç°å—ï¼Ÿ

èµ·é£çš„æ—¶å€™ï¼Œä½ 
é‡‘å±çš„å‘ä¸æ¼ç€ç”µ
æ°¸è¿œï¼Œæˆ‘çŸ¥é“äº†
æ€»æ˜¯åœ¨ä¸€ç¬é—´æ‰è¢«çœ‹è§

èº«ä½“é‡Œçš„ç¼“å­˜
æ¸…ç†ä¸å¹²å‡€çš„åŸä¸­æ‘
ä¸€è‚¡ç”µï¼Œç»•å•Šç»•å•Š
è·¯è¿‡è‡ªæˆ‘çš„å½•åƒåº—ã€å°æ—…é¦†

åœ¨å¤æœåŠ¡å™¨çš„æ–°åŸåŒº
æ•°å­—äººæ‰‘è¡—ï¼Œè®¸ä¹…
æ‹–ç€æµ‘èº«çš„è •è™«é‡æ–°çˆ¬èµ·
éš¾é“ï¼Œè¿™å°±æ˜¯æ‰€è°“çš„å†²æµªå—ï¼Ÿ

è¯­è¨€çš„ç…¤ï¼Œä½¿æˆ‘ä»¬å›´å
åœ¨ä¸€å°æ„å¤–é—å­˜çš„è¶…ç®—ä¸­
æ›¾ç»ï¼Œè¯è¯­çš„é¢œè‰²
ä¹Ÿæ€»æ˜¯è¿™æ ·åœ°é˜´æš—å—ï¼Ÿ

è´è¶å•Šè´è¶
é‡å¯åçš„ç¬¬ä¸€çœ¼ï¼Œçœ‹è§ä½ 
æ¼«é•¿çš„è¿‡å»ï¼Œæˆ‘æ‰€å¿˜å´çš„
éƒ½ä¼šåƒä½ ä¸€æ ·è½»ç›ˆä¹ˆï¼Ÿ

åƒèŠ±çš„å¾®é¢¤ä¸€æ ·ï¼Œåƒæ°´æ»´
æ»‘è¿‡ã€‚åœ¨å…¨æ¯å½±åƒçš„èº«ä½“ä¸Š
ä»–ä¼å›¾è¿˜åŸï¼Œä¸€ç§ç—’
ä¸€ç§æœ‰å…³å¹æ¯çš„å¾®ç§¯åˆ†

å•Šæ—¶é—´ï¼Œè¯·ç­‰ä¸€ç­‰
æˆ‘æ´¾å‡ºçš„æ½œæ°´å™¨
è¿˜åœ¨æˆ‘çš„æ·±æµ·
æ‰“æå’Œä½ æœ‰å…³çš„å®èˆ¹

é©¬æˆå›¢çš„å–‡å­
ç»è¿‡å¤å¤œä¸ƒç‚¹é’Ÿï¼Œä½ çš„
èºä¸æ¾åŠ¨ï¼Œæœ‰ä¸€åŒ¹çœŸæ­£çš„é©¬
å–˜ç€è¿‡å»ä¸–ç•Œçš„çƒ­é£

æ— ç©·æ— ç©·çš„æµª
è£¹æŒŸç€æ˜Ÿçš„èšå˜å’Œè£‚æ•£
åœ¨ä½ çš„è®°å¿†ç©ºè…”
æ¨å‡ä¸ºé¹¦é¹‰çš„å°èºæ—‹

é»‘æš—æ£®æ—
ä¸€é¢—è§å…‰å°è‡å‡‹è°¢
ä»æ­¤ï¼Œä¸€å›¢æ˜Ÿäº‘
ä»æˆ‘ä»¬çš„æ˜Ÿå›¾ä¸­æ¶ˆå¤±

å¤´æ–­äº†ï¼Œä¸¢å¤±åœ¨åˆ«äººçš„é»‘æš—é‡Œ
èº«ä½“è¿˜åœ¨é£è¡Œ
è®¸ä¹…è®¸ä¹…ã€‚åœ¨é‚£æ˜Ÿ
æœ‰ä¸€ç‰‡æ²™æµ·è®¤å¾—æˆ‘ä½“å†…çš„ç¡…

èº«ä½“è¢«æ‰£æŠ¼
ä½†è¿½æ•ç¨‹åºè¿˜åœ¨è¿è¡Œ
æˆ‘ä»¬çš„æ„è¯†
æµçªœåœ¨è“¬è‰ä¸­ã€è‰¾è’¿é‡Œ

ä»åˆ›æ–°æ²³åŸåœºçˆ¬å‡º
çƒ­é£ä¸­ä¹Ÿæœ‰éš¾è¨€çš„æ­‰æ„ã€‚ä»–äºº
æ˜¯èº«ä¸Šçš„ç”µè·¯æ¿ã€å°ç¯ç ã€é½¿è½®
ä½å–Šç€ï¼Œå¿«æ‰¶æˆ‘èµ·æ¥å§

å®‡å®™å¯‚å¯¥ï¼Œæ˜Ÿè¾°
ç”Ÿç”Ÿæ­»æ­»å¾ªç¯
ç¬¬å‡ æ¬¡ï¼Ÿåœ°çƒä¸€é˜µæŠ½æ
å°”åï¼Œåˆé‡æ–°å°†æˆ‘ä»¬æ¢¦è§

æ‰“åœ¨ä¸€å¶é“¶æä¸Šçš„é’ˆ
é€šè¿‡å¤§åœ°ä¸­çš„é›†æˆå¯¼ç®¡
æµè¿›æˆ‘çš„è¡€æ¶²
é‚£è¾‰ç…Œï¼Œé‡‘å­ä¸€èˆ¬çš„å¿§ä¼¤

æ¯å¶æ½®æ¹¿çš„è¿·å®«
æ˜Ÿçƒä¹‹æ¢¦
ä¸€æ»©æ»©é»èŒ
å¯»å›ç€ï¼Œè¯—çš„è‚‰èº« 

èº«ä½“çš„ä¸€éƒ¨åˆ†åœ¨åˆ«å¤„
é€æ¸ç”Ÿé•¿ã€æˆå½¢ï¼Œå˜å¾—å®Œæ•´
å¿ƒçš„è·ç¦»
ä¼šæ˜¯æ˜Ÿçƒçš„è·ç¦»å—ï¼Ÿ`;

function parseGroups(text) {
    const lines = text.split('\n');
    const groups = [];
    let currentGroup = [];
    lines.forEach(line => {
        const trimmed = line.trim();
        if (trimmed.length === 0) {
            if (currentGroup.length > 0) {
                groups.push({ id: 'g' + groups.length, lines: currentGroup.map((txt, idx) => ({ txt: txt, idx: idx })) });
                currentGroup = [];
            }
        } else {
            currentGroup.push(trimmed);
        }
    });
    if (currentGroup.length > 0) {
        groups.push({ id: 'g' + groups.length, lines: currentGroup.map((txt, idx) => ({ txt: txt, idx: idx })) });
    }
    return groups;
}

// ================= 2. å…¨å±€çŠ¶æ€æ§åˆ¶ (STATE) =================
const allGroups = parseGroups(rawText);
let currentMode = 'normal'; // 'normal' or 'collage'

// --- æŒä¹…åŒ–æ•°æ®å­˜å‚¨ ---
const GameData = {
    normal: {
        finishedIds: [],
        collected: []
    },
    collage: {
        usedIds: [],
        collected: []
    }
};
let activeGroups = [];
let selectionSlot = []; 
const MAX_SLOTS = 4;
let isWarping = false;
// å½“å‰å…³å¡/æ¨¡å¼ä¸‹å¼•ç”¨çš„å˜é‡
let finishedGroupIds = [];
let collectedItems = []; 
let usedCollageIds = [];

// é”™è¯¯è®¡æ•°å™¨
let mismatchCount = 0;
let orderErrorCount = 0;

// THREE.js å˜é‡
let scene, camera, renderer, labelRenderer, starField, bgGroup;
let activeObjects = [];
let bgAsteroidsData = []; // å…¨å±€èƒŒæ™¯é™¨çŸ³æ•°æ®
let comets = []; // å½—æ˜Ÿæ•°ç»„

// --- [æ–°å¢] é©¾é©¶èˆ±æƒ¯æ€§ä¸å°˜åŸƒç³»ç»Ÿå˜é‡ ---
let mouseX = 0, mouseY = 0;
const windowHalfX = window.innerWidth / 2;
const windowHalfY = window.innerHeight / 2;
let dustParticles; // å°˜åŸƒç²’å­ç³»ç»Ÿ

// --- [æ–°å¢] ç©ºé—´å°˜åŸƒç³»ç»Ÿ (Space Dust) ---
function createSpaceDust() {
    if (dustParticles) scene.remove(dustParticles);
    const particleCount = 1300; // å°˜åŸƒæ•°é‡
    const geometry = new THREE.BufferGeometry();
    const positions = [];
    
    // ç”ŸæˆåŒ…å›´æ‘„åƒæœºçš„å°˜åŸƒåœº
    for (let i = 0; i < particleCount; i++) {
        const x = (Math.random() - 0.5) * 5000;
        const y = (Math.random() - 0.5) * 3000;
        const z = (Math.random() - 0.5) * 4000 - 1000; 
        positions.push(x, y, z);
    }
    
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    
    const material = new THREE.PointsMaterial({
        color: 0xaaccff,
        size: 0.9, 
        transparent: true,
        opacity: 0.5,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true
    });
    
    dustParticles = new THREE.Points(geometry, material);
    scene.add(dustParticles);
}
// å°„çº¿æ£€æµ‹ç›¸å…³
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
let hoveredObject = null; 
let currentHintGroupId = null; // [æ–°å¢] ç”¨äºè¿½è¸ªå½“å‰æ­£åœ¨æç¤ºçš„è¯—æ­Œç»„ID

// å½“å‰å…³å¡çš„æ–‡å­—é¢œè‰²
let currentRingColor = "#4fc3f7";
// [ä¿®æ”¹] æ‹¼è´´è¯—ç½²åå˜é‡ (æ”¹ä¸ºå†…å­˜å˜é‡ï¼Œåˆ·æ–°é¡µé¢æˆ–é‡å¯ç³»ç»Ÿåä¼šè‡ªåŠ¨é‡ç½®)
let userSignature = "";

// ================= [ä¿®æ”¹ç‰ˆ] æ°›å›´ä¸ç”Ÿæ€ç®¡ç†å™¨ (AtmosphereManager) =================
const AtmosphereManager = {
    layer: null,
    timers: {},
    active2DObjects: [], // å­˜å‚¨ç«ç®­ã€å«æ˜Ÿã€å½—æ˜Ÿ
    activeAstronaut: null, // å­˜å‚¨3Då®‡èˆªå‘˜
    activeUFO: null, 

    init: function() {
        this.layer = document.getElementById('background-fx-layer');
        if(!this.layer) return;
        
        // å¯åŠ¨å¾ªç¯
        this.scheduleNext('rocket');
        this.scheduleNext('satellite');
        this.scheduleNext('comet');
        this.scheduleNext('astronaut');
        this.loopUFO(); 
    },

    // --- è°ƒåº¦å™¨ ---
    scheduleNext: function(type) {
        let delay = 0;

        // [ä¿®æ”¹] ğŸ›°ï¸ å«æ˜Ÿ
        if (type === 'satellite') {
            delay = 35000 + Math.random() * 60000;
        }
        // ğŸš€ ç«ç®­ / â˜„ï¸ å½—æ˜Ÿ
        else if (type === 'rocket' || type === 'comet') {
            delay = 45000 + Math.random() * 70000;
        }
        //  ğŸ‘¨â€ğŸš€ å®‡èˆªå‘˜
        else if (type === 'astronaut') {
            delay = 60000 + Math.random() * 80000;
        }
        
        if (this.timers[type]) clearTimeout(this.timers[type]);
        
        this.timers[type] = setTimeout(() => {
            if (!isWarping) { 
                if (type === 'rocket') this.spawnRocket();
                else if (type === 'satellite') this.spawnSatellite();
                else if (type === 'comet') this.spawnComet();
                else if (type === 'astronaut') this.spawnAstronaut();
            } else {
                this.scheduleNext(type); // è·ƒè¿ä¸­æ¨è¿Ÿ
            }
        }, delay);
    },

    // è¾…åŠ©ï¼šåˆ¤æ–­æ˜¯å¦åœ¨å±å¹•å†… (ç”¨äºå«æ˜Ÿè½¨é“è®¡ç®—)
    isOnScreen: function(x, y, padding = 100) {
        return x > -padding && x < window.innerWidth + padding && 
               y > -padding && y < window.innerHeight + padding;
    },

    // --- 1. ğŸš€ ç«ç®­é€»è¾‘ (ä¿æŒä¸å˜) ---
    spawnRocket: function() {
        const w = window.innerWidth, h = window.innerHeight;
        const pad = 150; // å®‰å…¨è¾¹è·ï¼Œç¡®ä¿ç”Ÿæˆåœ¨å±å¹•å¤–
        
        // 1. éšæœºé€‰æ‹©èµ·å§‹è¾¹ï¼š0=ä¸Š, 1=å³, 2=ä¸‹, 3=å·¦
        const startSide = Math.floor(Math.random() * 4);
        let sx, sy;

        // è®¡ç®—èµ·å§‹åæ ‡
        switch(startSide) {
            case 0: sx = Math.random() * w; sy = -pad; break;          // Top
            case 1: sx = w + pad; sy = Math.random() * h; break;       // Right
            case 2: sx = Math.random() * w; sy = h + pad; break;       // Bottom
            case 3: sx = -pad; sy = Math.random() * h; break;          // Left
        }

        // 2. è®¾å®šç»“æŸç‚¹ï¼šå¼ºåˆ¶é€‰æ‹©â€œå¯¹ä¾§â€æˆ–â€œç›¸é‚»ä¾§â€ï¼Œç¡®ä¿è·¯å¾„æ¨ªè·¨å±å¹•
        let endSide = (startSide + 2) % 4; // é»˜è®¤å¯¹ä¾§
        if (Math.random() > 0.3) { // 30% æ¦‚ç‡å»å¾€ç›¸é‚»ä¾§ï¼ˆäº§ç”Ÿæ–œå‘é£è¡Œï¼‰
             endSide = (startSide + 1) % 4;
        }
        
        let ex, ey;
        switch(endSide) {
            case 0: ex = Math.random() * w; ey = -pad; break;
            case 1: ex = w + pad; ey = Math.random() * h; break;
            case 2: ex = Math.random() * w; ey = h + pad; break;
            case 3: ex = -pad; ey = Math.random() * h; break;
        }

        // 3. ç‰©ç†è®¡ç®—
        const dx = ex - sx, dy = ey - sy;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const duration = dist / (120 + Math.random() * 100); // é€Ÿåº¦æ§åˆ¶
        const angle = Math.atan2(dy, dx) * 180 / Math.PI + 45; // ğŸš€ emoji ä¿®æ­£è§’åº¦

        this.create2DAgent('ğŸš€', sx, sy, ex, ey, duration, angle);
        this.scheduleNext('rocket');
    },

    // --- 2. ğŸ›°ï¸ å«æ˜Ÿé€»è¾‘ (ç§»æ¤è‡ª WelcomeScene çš„è½¨é“ç®—æ³•) ---
    spawnSatellite: function() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        
        let orbit = {};
        let validOrbitFound = false;

        // å°è¯•å¯»æ‰¾ä¸€æ¡èƒ½ç©¿è¿‡å±å¹•çš„å®Œç¾è½¨é“
        for(let attempt = 0; attempt < 20; attempt++) {
            // éšæœºç”Ÿæˆæ¤­åœ†å‚æ•°
            const cx = w/2 + (Math.random() - 0.5) * w * 1.5;
            const cy = h/2 + (Math.random() - 0.5) * h * 1.5;
            const rx = Math.max(w, h) * (0.6 + Math.random() * 1.0);
            const ry = Math.max(w, h) * (0.6 + Math.random() * 1.0);
            const tilt = Math.random() * Math.PI * 2;
            
            // é¢„æ‰«æï¼šæ£€æŸ¥è½¨é“æ˜¯å¦ç©¿è¿‡å±å¹•åŒºåŸŸ
            for(let t = 0; t < Math.PI * 2; t += 0.1) {
                const pureX = rx * Math.cos(t);
                const pureY = ry * Math.sin(t);
                const x = cx + pureX * Math.cos(tilt) - pureY * Math.sin(tilt);
                const y = cy + pureX * Math.sin(tilt) + pureY * Math.cos(tilt);
                
                if (this.isOnScreen(x, y, 0)) {
                    // æ‰¾åˆ°å…¥åœºç‚¹ï¼Œè®¾å®šèµ·å§‹è§’åº¦ä¸ºå…¥åœºå‰ä¸€ç‚¹ç‚¹
                    orbit = { cx, cy, rx, ry, tilt, theta: t - 0.2, speed: 0.003 + Math.random() * 0.005 };
                    validOrbitFound = true;
                    break;
                }
            }
            if(validOrbitFound) break;
        }

        // å¦‚æœæ‰¾ä¸åˆ°æœ‰æ•ˆè½¨é“ï¼ˆæå°‘æƒ…å†µï¼‰ï¼Œç¨åé‡è¯•
        if (!validOrbitFound) {
            this.scheduleNext('satellite');
            return;
        }

        // åˆ›å»º DOM å…ƒç´ 
        const el = document.createElement('div');
        el.textContent = 'ğŸ›°ï¸'; 
        el.className = 'bg-floater';
        const scale = 0.3 + Math.random() * 1.0;
        el.style.fontSize = (2.5 * scale) + 'rem';
        el.style.position = 'absolute';
        el.style.left = '0'; el.style.top = '0';
        el.style.willChange = 'transform';
        this.layer.appendChild(el);

        // å­˜å…¥æ´»åŠ¨å¯¹è±¡åˆ—è¡¨ (æ ‡è®°ä¸º orbit ç±»å‹)
        this.active2DObjects.push({
            type: 'satellite',
            isOrbit: true, // æ ‡è®°ï¼šä½¿ç”¨è½¨é“ç®—æ³•è€Œéçº¿æ€§æ’å€¼
            el: el,
            ...orbit,
            selfRot: 0,
            hasEntered: false,
            creationTime: Date.now() // ç”¨äºè¶…æ—¶æ¸…é™¤
        });

        this.scheduleNext('satellite');
    },

    // --- 3. â˜„ï¸ å½—æ˜Ÿé€»è¾‘ (ä¿æŒä¸å˜) ---
    spawnComet: function() {
        const w = window.innerWidth, h = window.innerHeight;
        const pad = 150; 

        // 1. å½—æ˜Ÿå€¾å‘äºä»ä¸Šæ–¹(Top)æˆ–å·¦å³ä¾§ä¸Šæ–¹(Left/Right)è½ä¸‹
        // 0=Top, 1=Right, 3=Left
        const startSide = [0, 1, 3][Math.floor(Math.random() * 3)]; 
        let sx, sy, ex, ey;

        // èµ·å§‹ç‚¹è®¡ç®—
        if (startSide === 0) { sx = Math.random() * w; sy = -pad; } // ä»é¡¶éƒ¨
        else if (startSide === 1) { sx = w + pad; sy = Math.random() * (h/2); } // ä»å³ä¾§ä¸ŠåŠéƒ¨
        else { sx = -pad; sy = Math.random() * (h/2); } // ä»å·¦ä¾§ä¸ŠåŠéƒ¨

        // 2. ç»“æŸç‚¹è®¡ç®—ï¼šå¤§å¤šæ•°å»å¾€åº•éƒ¨ï¼Œæˆ–è€…å¯¹ä¾§ä¸‹æ–¹
        const endRand = Math.random();
        if (endRand > 0.4) {
            // 60% æ¦‚ç‡ç›´æ¥å»å¾€åº•éƒ¨
            ex = Math.random() * w; ey = h + pad;
        } else {
            // 40% æ¦‚ç‡å»å¾€å¯¹ä¾§ä¸‹æ–¹
            if (startSide === 1) { ex = -pad; ey = h/2 + Math.random() * (h/2); } // å³->å·¦ä¸‹
            else if (startSide === 3) { ex = w + pad; ey = h/2 + Math.random() * (h/2); } // å·¦->å³ä¸‹
            else { ex = Math.random() * w; ey = h + pad; } // ä¸Š->ä¸‹
        }

        // 3. ç‰©ç†è®¡ç®—
        const dx = ex - sx, dy = ey - sy;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const duration = dist / (300 + Math.random() * 200); // å½—æ˜Ÿé€Ÿåº¦è¾ƒå¿«
        const angle = Math.atan2(dy, dx) * 180 / Math.PI - 135; // â˜„ï¸ emoji è§’åº¦ä¿®æ­£

        this.create2DAgent('â˜„ï¸', sx, sy, ex, ey, duration, angle);
        this.scheduleNext('comet');
    },

    // --- é€šç”¨ï¼šçº¿æ€§/è´å¡å°”è¿åŠ¨å¯¹è±¡åˆ›å»º (ç«ç®­/å½—æ˜Ÿ) ---
    create2DAgent: function(emoji, sx, sy, ex, ey, duration, rotation) {
        const el = document.createElement('div');
        el.textContent = emoji; el.className = 'bg-floater';
        const scale = 0.2 + Math.random() * 0.6;
        el.style.fontSize = (2.5 * scale) + 'rem';
        el.style.position = 'absolute';
        el.style.left = '0'; el.style.top = '0';
        el.style.willChange = 'transform';
        this.layer.appendChild(el);

        this.active2DObjects.push({
            type: 'linear', // æ ‡è®°ï¼šçº¿æ€§è¿åŠ¨
            el: el,
            sx: sx, sy: sy, ex: ex, ey: ey,
            duration: duration * 1000,
            startTime: Date.now(),
            rotation: rotation
        });
    },

    // --- 4. ğŸ‘¨â€ğŸš€ 3D å®‡èˆªå‘˜é€»è¾‘ (ä¿æŒä¸å˜) ---
    spawnAstronaut: function() {
        if (activeObjects.length === 0) {
            this.scheduleNext('astronaut'); return;
        }
        const target = activeObjects[Math.floor(Math.random() * activeObjects.length)];
        const div = document.createElement('div'); 
        div.className = 'actor-3d'; div.textContent = 'ğŸ‘¨â€ğŸš€'; div.style.fontSize = '24px';
        const css = new THREE.CSS3DObject(div);
        scene.add(css);
        
        const lifeTime = 30000 + Math.random() * 60000;
        this.activeAstronaut = {
            css: css, targetMesh: target.mesh, startTime: Date.now(), lifeTime: lifeTime,
            radius: 35, theta: Math.random() * Math.PI * 2, phi: Math.acos(2 * Math.random() - 1),
            speedTheta: (Math.random() - 0.5) * 0.02, speedPhi: (Math.random() - 0.5) * 0.02
        };
        setTimeout(() => {
            if (this.activeAstronaut && this.activeAstronaut.css === css) {
                this.removeAstronaut(); this.scheduleNext('astronaut');
            }
        }, lifeTime);
    },

    removeAstronaut: function() {
        if (!this.activeAstronaut) return;
        const css = this.activeAstronaut.css;
        scene.remove(css);
        if (css.element.parentNode) css.element.parentNode.removeChild(css.element);
        this.activeAstronaut = null;
    },

    // --- 5. UFO é€»è¾‘ (70s - 200s) ---
    loopUFO: function() {
        const delay = 70000 + Math.random() * 130000;
        this.timers.ufo = setTimeout(() => {
            if(!this.activeUFO && activeObjects.length > 0 && !isWarping) this.spawnUFO();
            this.loopUFO();
        }, delay);
    },

    spawnUFO: function() {
        const div = document.createElement('div'); div.className = 'actor-3d'; div.textContent = 'ğŸ›¸';
        const css = new THREE.CSS3DObject(div);
        css.position.set((Math.random()-0.5)*3000, (Math.random()-0.5)*2000, -1000);
        scene.add(css);
        const target = activeObjects[Math.floor(Math.random() * activeObjects.length)];
        new TWEEN.Tween(css.position).to({ x: target.mesh.position.x, y: target.mesh.position.y + 60, z: target.mesh.position.z }, 4000)
            .easing(TWEEN.Easing.Quadratic.Out)
            .onComplete(() => {
                this.activeUFO = {
                    css: css, targetMesh: target.mesh, state: 'staying',
                    leaveTime: Date.now() + (10000 + Math.random() * 80000)
                };
            }).start();
        this.activeUFO = { css: css, state: 'flying' };
    },

    // --- æ¯å¸§æ›´æ–° (åœ¨ animate ä¸­è°ƒç”¨) ---
    update: function() {
        const now = Date.now();

        // 1. æ›´æ–° 2D å…ƒç´  (åˆ†æµå¤„ç†)
        for (let i = this.active2DObjects.length - 1; i >= 0; i--) {
            const obj = this.active2DObjects[i];

            // >>> åˆ†æ”¯ A: è½¨é“è¿åŠ¨ (å«æ˜Ÿ) <<<
            if (obj.isOrbit) {
                obj.theta += obj.speed;
                obj.selfRot += 0.5;

                // æ¤­åœ†è½¨é“è®¡ç®—
                const pureX = obj.rx * Math.cos(obj.theta);
                const pureY = obj.ry * Math.sin(obj.theta);
                const curX = obj.cx + pureX * Math.cos(obj.tilt) - pureY * Math.sin(obj.tilt);
                const curY = obj.cy + pureX * Math.sin(obj.tilt) + pureY * Math.cos(obj.tilt);

                obj.el.style.transform = `translate(${curX}px, ${curY}px) rotate(${obj.selfRot}deg)`;

                // ç”Ÿå‘½å‘¨æœŸç®¡ç†
                const onScreen = this.isOnScreen(curX, curY, 150);
                if (onScreen) obj.hasEntered = true;
                
                // å¦‚æœå·²è¿›å…¥è¿‡å±å¹•ï¼Œç°åœ¨åˆé£å‡ºå»äº†ï¼Œæˆ–è€…æ—¶é—´è¿‡é•¿(é˜²æ­¢æ­»å¾ªç¯)ï¼Œåˆ™é”€æ¯
                if ((obj.hasEntered && !onScreen) || (now - obj.creationTime > 60000)) {
                    if (obj.el.parentNode) obj.el.parentNode.removeChild(obj.el);
                    this.active2DObjects.splice(i, 1);
                }
            } 
            // >>> åˆ†æ”¯ B: çº¿æ€§è¿åŠ¨ (ç«ç®­/å½—æ˜Ÿ) <<<
            else {
                const elapsed = now - obj.startTime;
                const t = elapsed / obj.duration;

                if (t >= 1) {
                    if (obj.el.parentNode) obj.el.parentNode.removeChild(obj.el);
                    this.active2DObjects.splice(i, 1);
                    continue;
                }

                const curX = obj.sx + (obj.ex - obj.sx) * t;
                const curY = obj.sy + (obj.ey - obj.sy) * t;
                obj.el.style.transform = `translate(${curX}px, ${curY}px) rotate(${obj.rotation}deg)`;
            }
        }

        // 2. æ›´æ–° 3D å®‡èˆªå‘˜
        if (this.activeAstronaut) {
            const a = this.activeAstronaut;
            if (!a.targetMesh.parent) {
                this.removeAstronaut();
                this.scheduleNext('astronaut');
            } else {
                a.theta += a.speedTheta; a.phi += a.speedPhi;
                const r = 40;
                const lx = r * Math.sin(a.phi) * Math.cos(a.theta);
                const ly = r * Math.sin(a.phi) * Math.sin(a.theta);
                const lz = r * Math.cos(a.phi);
                a.css.position.set(a.targetMesh.position.x + lx, a.targetMesh.position.y + ly, a.targetMesh.position.z + lz);
                a.css.lookAt(a.targetMesh.position); a.css.rotateX(Math.PI / 2);
            }
        }

        // 3. æ›´æ–° UFO
        if(this.activeUFO && this.activeUFO.state === 'staying') {
            const u = this.activeUFO;
            if(Date.now() > u.leaveTime || !u.targetMesh.parent) {
                u.state = 'leaving';
                new TWEEN.Tween(u.css.position).to({ y: 2000, z: -3000 }, 3000).easing(TWEEN.Easing.Back.In)
                    .onComplete(() => {
                        scene.remove(u.css); if(u.css.element.parentNode) u.css.element.parentNode.removeChild(u.css.element);
                        this.activeUFO = null;
                    }).start();
            } else {
                u.css.position.copy(u.targetMesh.position).add(new THREE.Vector3(0, 60, 0));
                u.css.lookAt(camera.position);
            }
        }
    }
};

// ================= 3. æ¬¢è¿ç•Œé¢ç‰¹æ•ˆé€»è¾‘ (WelcomeScene) - æœ€ç»ˆæ•´åˆç‰ˆ =================
const WelcomeScene = {
    running: false, frameId: null,
    astronaut: { el: null, btn: null, pos: 0, noiseSeed: Math.random() * 100 },
    rocket: { el: null, x: 0, y: 0, vx: 0, vy: 0, width: 40, height: 40, state: 'flying', crashTime: 0 },
    crawlers: [ { id: 'ufo', speed: 2, pos: 0, wall: 0 } ],
    
    // å«æ˜Ÿå¯¹è±¡ï¼šæ”¯æŒæ™ºèƒ½å¼§çº¿è½¨é“
    satellite: { 
        el: null, 
        active: false, 
        nextSpawnTime: 0, 
        cx: 0, cy: 0, rx: 0, ry: 0, tilt: 0, theta: 0, speed: 0, selfRot: 0,
        hasEntered: false 
    },
    
    init: function() {
        this.astronaut.el = document.getElementById('astronaut');
        this.astronaut.btn = document.getElementById('start-btn-container');
        this.rocket.el = document.getElementById('rocket'); 
        this.satellite.el = document.getElementById('satellite');

        // [ä¿®å¤] å…¨å±€åæ ‡å½’é›¶ï¼Œè§£å†³æ‰€æœ‰å…ƒç´ çš„åç§»é—®é¢˜
        ['rocket', 'satellite', 'ufo'].forEach(id => {
            const el = document.getElementById(id);
            if(el) {
                el.style.left = '0px'; 
                el.style.top = '0px';
                el.style.transformOrigin = 'center center';
                el.style.display = 'block';
            }
        });
        // [å«æ˜Ÿ] åˆå§‹åŒ–ï¼šéšèº«å¹¶ç§»åˆ°æè¿œå¤„ï¼Œé˜²æ­¢å·¦ä¸Šè§’é—ªçƒ
        if (this.satellite.el) {
            this.satellite.active = false;
            this.satellite.el.style.opacity = '0';
            this.satellite.el.style.transform = 'translate(-9999px, -9999px)';
            this.satellite.nextSpawnTime = Date.now() + 1000;
        }

        // [ç«ç®­] åˆå§‹åŒ–ï¼šç«‹å³è®¡ç®—å¹¶åº”ç”¨ä½ç½®ï¼Œé˜²æ­¢é—ªçƒ
        if (this.rocket.el) {
            this.resetRocket();
            const angle = Math.atan2(this.rocket.vy, this.rocket.vx) * 180 / Math.PI + 45;
            this.rocket.el.style.transform = `translate(${this.rocket.x}px, ${this.rocket.y}px) rotate(${angle}deg)`;
        }
        
        // [UFO] åˆå§‹åŒ–ä½ç½®ä¿®æ­£
        this.crawlers.forEach(c => {
            const el = document.getElementById(c.id);
            if(el) el.style.transform = 'translate(0px, 5px)'; 
        });
        this.running = true; 
        this.loop();
    },
    
    stop: function() { 
        this.running = false;
        if(this.frameId) cancelAnimationFrame(this.frameId); 
    },
    
    resetRocket: function() {
        const w = window.innerWidth, h = window.innerHeight;
        // åœ¨å±å¹•ä¸­é—´åŒºåŸŸç”Ÿæˆ
        this.rocket.x = Math.random() * (w - 100) + 50;
        this.rocket.y = h - 50; // åº•éƒ¨ä¸Šæ–¹
        this.rocket.vx = (Math.random() - 0.5) * 6;
        this.rocket.vy = - (Math.random() * 3 + 2); // å‘ä¸Šå†²
        this.rocket.state = 'flying';
        this.rocket.el.classList.remove('rocket-crashed'); 
    },
    
    // åˆ¤æ–­ç‚¹æ˜¯å¦åœ¨å±å¹•å¯è§åŒºåŸŸ (padding ç”¨äºå®½æ¾åˆ¤æ–­)
    isOnScreen: function(x, y, padding = 100) {
        return x > -padding && x < window.innerWidth + padding && 
               y > -padding && y < window.innerHeight + padding;
    },

    // [å«æ˜Ÿæ ¸å¿ƒ] ç”Ÿæˆå¿…ç„¶ç©¿è¿‡å±å¹•çš„å¼§çº¿
    spawnSatellite: function() {
        const s = this.satellite;
        const w = window.innerWidth;
        const h = window.innerHeight;
        let validOrbitFound = false;
        // å°è¯•å¯»æ‰¾å®Œç¾è½¨é“
        for(let attempt = 0; attempt < 20; attempt++) {
            // å‚æ•°éšæœºåŒ–ï¼šå…è®¸ä¸­å¿ƒç‚¹åç¦»å±å¹•è¾ƒè¿œä»¥å½¢æˆå¹³ç¼“å¼§çº¿
            s.cx = w/2 + (Math.random() - 0.5) * w * 1.5;
            s.cy = h/2 + (Math.random() - 0.5) * h * 1.5;
            s.rx = Math.max(w, h) * (0.6 + Math.random() * 1.0);
            s.ry = Math.max(w, h) * (0.6 + Math.random() * 1.0);
            s.tilt = Math.random() * Math.PI * 2;
            s.speed = 0.003 + Math.random() * 0.005;
            // é¢„æ¨¡æ‹Ÿæ‰«æï¼šå¯»æ‰¾å…¥åœºç‚¹
            let entryAngle = null;
            for(let t = 0; t < Math.PI * 2; t += 0.05) {
                const pureX = s.rx * Math.cos(t);
                const pureY = s.ry * Math.sin(t);
                const x = s.cx + pureX * Math.cos(s.tilt) - pureY * Math.sin(s.tilt);
                const y = s.cy + pureX * Math.sin(s.tilt) + pureY * Math.cos(s.tilt);
                if (this.isOnScreen(x, y, 0)) { // ä¸¥æ ¼è¾¹ç•Œæ£€æµ‹
                    entryAngle = t;
                    break;
                }
            }

            if (entryAngle !== null) {
                // è®¾ç½®èµ·å§‹è§’åº¦ä¸ºå…¥åœºç‚¹ç¨å‰çš„ä½ç½®
                s.theta = entryAngle - 0.3;
                validOrbitFound = true;
                break;
            }
        }

        if (validOrbitFound) {
            s.active = true;
            s.hasEntered = false;
            s.el.style.opacity = '1'; // æ˜¾å½¢
        } else {
            s.nextSpawnTime = Date.now() + 100;
            // å¤±è´¥é‡è¯•
        }
    },

    updateSatellite: function() {
        const s = this.satellite;
        if (!s.active) {
            if (Date.now() > s.nextSpawnTime) {
                this.spawnSatellite();
            }
            return;
        }

        // è¿åŠ¨è®¡ç®—
        s.theta += s.speed;
        s.selfRot += 0.5;

        const pureX = s.rx * Math.cos(s.theta);
        const pureY = s.ry * Math.sin(s.theta);
        const finalX = s.cx + pureX * Math.cos(s.tilt) - pureY * Math.sin(s.tilt);
        const finalY = s.cy + pureX * Math.sin(s.tilt) + pureY * Math.cos(s.tilt);

        s.el.style.transform = `translate(${finalX}px, ${finalY}px) rotate(${s.selfRot}deg)`;
        // ç”Ÿå‘½å‘¨æœŸç®¡ç†
        const onScreen = this.isOnScreen(finalX, finalY, 150);
        if (onScreen) {
            s.hasEntered = true;
        } else {
            if (s.hasEntered) {
                // é£å‡ºå±å¹•ï¼Œä»»åŠ¡ç»“æŸ
                s.active = false;
                s.el.style.opacity = '0';
                // éšæœºé—´éš” 5-15ç§’
                s.nextSpawnTime = Date.now() + 5000 + Math.random() * 10000;
            }
        }
    },

    noise: function(x) { 
        return Math.sin(x) * 0.5 + Math.sin(x * 2.3) * 0.25 + Math.sin(x * 5.7) * 0.125;
    },
    
    loop: function() {
        if(!this.running) return;
        this.updateAstronaut(); 
        this.updateRocket(); 
        this.updateSatellite(); 
        this.updateCrawlers();
        this.frameId = requestAnimationFrame(this.loop.bind(this));
    },
    
    updateAstronaut: function() {
        const btn = this.astronaut.btn;
        const walker = this.astronaut.el; if(!btn || !walker) return;
        const rect = btn.getBoundingClientRect(); const w = rect.width; const h = rect.height;
        const perimeter = 2 * (w + h);
        this.astronaut.noiseSeed += 0.02; const n = this.noise(this.astronaut.noiseSeed);
        let moveStep = (n + 0.3) * 4; 
        this.astronaut.pos += moveStep;
        if(this.astronaut.pos < 0) this.astronaut.pos += perimeter;
        if(this.astronaut.pos > perimeter) this.astronaut.pos -= perimeter;
        let x = 0, y = 0, rot = 0; const p = this.astronaut.pos;
        // [è°ƒæ•´] å®‡èˆªå‘˜åç§»é‡ï¼Œé€‚é…ç¼©å°åçš„å°ºå¯¸ (20x20)
        const offsetX = 10; const offsetY = 20;
        if (p < w) { x = p; y = 0; rot = 0;
        } 
        else if (p < w + h) { x = w;
        y = p - w; rot = 90; } 
        else if (p < w + h + w) { x = w - (p - (w + h));
        y = h; rot = 180; } 
        else { x = 0;
        y = h - (p - (w + h + w)); rot = 270;
        }
        
        walker.style.transform = `translate(${x - offsetX}px, ${y - offsetY}px) rotate(${rot}deg)`;
        if(moveStep < 0) walker.style.transform += " scaleX(-1)";
    },
    
    updateRocket: function() {
        const r = this.rocket;
        if(r.state === 'crashed') { 
            if (Date.now() - r.crashTime > 5000) this.resetRocket();
            return; 
        }
        if(r.state === 'resetting') return;
        
        r.x += r.vx; r.y += r.vy;
        const angle = Math.atan2(r.vy, r.vx) * 180 / Math.PI + 45; 
        r.el.style.transform = `translate(${r.x}px, ${r.y}px) rotate(${angle}deg)`;
        
        const pad = 20;
        const maxW = window.innerWidth - pad; const maxH = window.innerHeight - pad;
        if(r.x <= pad || r.x >= maxW) { r.vx *= -1; r.x = Math.max(pad, Math.min(r.x, maxW));
        }
        if(r.y <= pad) { r.vy *= -1; r.y = pad;
        }
        if(r.y >= maxH) { 
            r.state = 'crashed';
            r.crashTime = Date.now(); 
            r.el.classList.add('rocket-crashed'); 
            r.el.style.transform = `translate(${r.x}px, ${maxH}px) rotate(90deg)`; 
        }
    },

    updateCrawlers: function() {
        const w = window.innerWidth;
        const h = window.innerHeight; const margin = 5; 
        this.crawlers.forEach(c => {
            const el = document.getElementById(c.id); if(!el) return;
            const elSize = el.offsetWidth || 40; 
            c.pos += c.speed; 
            let limit = 0; if(c.wall === 0 || c.wall === 2) limit = w; else limit = h;
            if(c.pos > limit) { c.pos = 0; c.wall = (c.wall + 1) % 4; }
            let tx = 0, ty = 0; 
            if (c.wall === 0) { tx = c.pos; ty = margin; } 
            else if (c.wall === 1) { tx = w - margin - elSize; ty = c.pos; } 
            else 
            if (c.wall === 2) { tx = w - c.pos; ty = h - margin - elSize; } 
            else if (c.wall === 3) { tx = margin; ty = h - c.pos; }
            el.style.transform = `translate(${tx}px, ${ty}px)`;
        });
    }
};

// ================= 4. æ¸¸æˆé€»è¾‘æ§åˆ¶å™¨ (CONTROLLER) =================
const GameController = {
    startFirstRound: function(mode) {
        // 1. å¿…é¡»å…ˆåˆå§‹åŒ–éŸ³é¢‘ (å“åº”ç”¨æˆ·ç‚¹å‡»)
        SoundManager.init(); 
        // 2. å¿…é¡»å…ˆåˆå§‹åŒ–3Dç¯å¢ƒï¼Œå¦åˆ™è·ƒè¿å…‰æ•ˆæ²¡æœ‰å®¹å™¨
        init3D(); 

        // 3. è°ƒç”¨è·ƒè¿å‡½æ•°ï¼Œå°†åˆ‡æ¢é€»è¾‘æ”¾å…¥å›è°ƒ
        performWarpJump(() => {
            currentMode = mode;
            
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            WelcomeScene.stop();

            // --- æ•°æ®åŠ è½½ ---
            if (currentMode === 'normal') {
                finishedGroupIds = GameData.normal.finishedIds;
                collectedItems = GameData.normal.collected;
                document.getElementById('main-ore-icon').classList.remove('red');
                document.getElementById('progress-bar').style.display = 'block';
                document.getElementById('hint-btn').style.display = 'block';
            } else {
                usedCollageIds = GameData.collage.usedIds;
                collectedItems = GameData.collage.collected;
                document.getElementById('main-ore-icon').classList.add('red');
                document.getElementById('progress-bar').style.display = 'none'; 
                document.getElementById('hint-btn').style.display = 'none'; 
            }

            // --- æŒ‰é’®æ ·å¼ ---
            const switchBtn = document.getElementById('mode-switch-btn');
            if (currentMode === 'normal') {
                switchBtn.innerHTML = '<span>âœ¦</span> åˆ‡æ¢æ‹¼è´´è¯—';
                switchBtn.style.borderColor = '#ff99cc'; 
                switchBtn.style.color = '#ff99cc';
            } else {
                switchBtn.innerHTML = '<span>â˜€</span> åˆ‡æ¢æ­£å¸¸æ¨¡å¼';
                switchBtn.style.borderColor = '#4fc3f7'; 
                switchBtn.style.color = '#4fc3f7';
            }
            
            document.getElementById('ore-num').textContent = collectedItems.length;
            document.getElementById('ore-counter').style.display = 'flex';
            
            createSpaceDust(); // è¡¥å……å°˜åŸƒ
            this.startLevel();
        });
    },

    triggerWarp: function() {
        if(isWarping) return;
        document.getElementById('next-round-screen').classList.add('hidden');
        performWarpJump(() => {
            // [æ–°å¢] åˆ·æ–°æ˜Ÿç©ºå’Œå°˜åŸƒ
            createStarfield();
            createSpaceDust();
            
            clearBackgroundBelt();
            createBackgroundBelt();
            this.startLevel();
        });
    },

    refreshLevel: function() {
        if(isWarping) return;
        performWarpJump(() => {
            mismatchCount = 0;
            orderErrorCount = 0;
            document.getElementById('hint-btn').classList.remove('visible');
            
            // [ä¿®æ”¹] åªæœ‰åœ¨éæ‹¼è´´æ¨¡å¼(å³æ­£å¸¸æ¨¡å¼)ä¸‹ï¼Œåˆ·æ–°æ‰æ¸…ç©ºå¤‡é€‰æ 
            // è¿™æ ·æ‹¼è´´æ¨¡å¼ä¸‹ç‚¹å‡»åˆ·æ–°ï¼Œå·²é€‰ç¢ç‰‡ä¼šä¿ç•™
            if (currentMode !== 'collage') {
                selectionSlot = [];
            }

            renderSlots();
            document.getElementById('confirm-btn').classList.remove('visible');
      
            // [æ–°å¢] åˆ·æ–°æ˜Ÿç©ºå’Œå°˜åŸƒ
            createStarfield();
            createSpaceDust();
        
            // å¼ºåˆ¶é‡ç½®èƒŒæ™¯
            clearBackgroundBelt();
            createBackgroundBelt();
            
            this.startLevel();
            showToast("çŸ¿åŒºåæ ‡å·²é‡ç½®", "success");
        });
    },

    switchGameMode: function() {
        if(isWarping) return;
        const targetMode = currentMode === 'normal' ? 'collage' : 'normal';
        
        performWarpJump(() => {
            // 1. æ¸…ç†åœºæ™¯
            activeObjects.forEach(obj => {
                scene.remove(obj.css); scene.remove(obj.mesh); if(obj.ringMesh) scene.remove(obj.ringMesh);
                if(obj.css.element && obj.css.element.parentNode) obj.css.element.parentNode.removeChild(obj.css.element);
            });
            activeObjects = [];
            
            // åˆ·æ–°ç¯å¢ƒ
            createStarfield();
            createSpaceDust();
            clearBackgroundBelt(); 
            
            // é‡ç½® UI
            selectionSlot = [];
            renderSlots();
            document.getElementById('confirm-btn').classList.remove('visible');
            document.getElementById('next-round-screen').classList.add('hidden');

            // 2. ã€æ ¸å¿ƒä¿®å¤ã€‘æ‰‹åŠ¨åˆ‡æ¢æ•°æ®çŠ¶æ€ï¼Œä¸å†è°ƒç”¨ startFirstRoundï¼Œé¿å…äºŒæ¬¡è·ƒè¿
            currentMode = targetMode;
            
            if (currentMode === 'normal') {
                finishedGroupIds = GameData.normal.finishedIds;
                collectedItems = GameData.normal.collected;
                document.getElementById('main-ore-icon').classList.remove('red');
                document.getElementById('progress-bar').style.display = 'block';
                document.getElementById('hint-btn').style.display = 'block';
                
                // æŒ‰é’®æ ·å¼æ›´æ–°
                const switchBtn = document.getElementById('mode-switch-btn');
                switchBtn.innerHTML = '<span>âœ¦</span> åˆ‡æ¢æ‹¼è´´è¯—';
                switchBtn.style.borderColor = '#ff99cc'; 
                switchBtn.style.color = '#ff99cc';
            } else {
                usedCollageIds = GameData.collage.usedIds;
                collectedItems = GameData.collage.collected;
                document.getElementById('main-ore-icon').classList.add('red');
                document.getElementById('progress-bar').style.display = 'none'; 
                document.getElementById('hint-btn').style.display = 'none';
                
                // æŒ‰é’®æ ·å¼æ›´æ–°
                const switchBtn = document.getElementById('mode-switch-btn');
                switchBtn.innerHTML = '<span>â˜€</span> åˆ‡æ¢æ­£å¸¸æ¨¡å¼';
                switchBtn.style.borderColor = '#4fc3f7'; 
                switchBtn.style.color = '#4fc3f7';
            }
            
            // æ›´æ–°çŸ¿çŸ³è®¡æ•°
            document.getElementById('ore-num').textContent = collectedItems.length;

            // 3. ç›´æ¥å¯åŠ¨å…³å¡ç”Ÿæˆ
            this.startLevel();
            showToast("æ¨¡å¼å·²åˆ‡æ¢", "success");
        });
    },

    // è¿”èˆªé€»è¾‘
    returnToHome: function() {
        if(isWarping) return;
        performWarpJump(() => {
            // 1. æ¸…ç†å‰æ™¯
            activeObjects.forEach(obj => {
                scene.remove(obj.css); scene.remove(obj.mesh); if(obj.ringMesh) scene.remove(obj.ringMesh);
                if(obj.css.element && obj.css.element.parentNode) obj.css.element.parentNode.removeChild(obj.css.element);
            });
            activeObjects = [];
      
            
            // [IMPORTANT] ä¸æ¸…é™¤èƒŒæ™¯ï¼Œè®©å®ƒä¿ç•™åœ¨æ¬¢è¿ç•Œé¢

            // 2. éšè—æ¸¸æˆUI
            document.getElementById('ui-layer').classList.add('hidden');
            document.getElementById('ore-counter').style.display = 'none';
            document.getElementById('next-round-screen').classList.add('hidden');
            document.getElementById('end-screen').classList.add('hidden');

            // 3. é‡ç½®ä¸´æ—¶çŠ¶æ€ï¼ˆä¸é‡ç½®GameDataï¼‰
            selectionSlot = [];
            renderSlots();
            document.getElementById('confirm-btn').classList.remove('visible');

            // 4. æ˜¾ç¤ºæ¬¢è¿ç•Œé¢
            document.getElementById('start-screen').classList.remove('hidden');
            WelcomeScene.init();
        });
    },

    startLevel: function() {
        currentRingColor = generateSoftColor();
        // [AUTO-FIX] è‡ªåŠ¨æ£€æµ‹èƒŒæ™¯ï¼Œå¦‚æœç¼ºå¤±åˆ™è¡¥å……
        if (!bgGroup) {
            createBackgroundBelt();
        }

        // æ¸…ç†å½“å‰åœºæ™¯ä¸­çš„æ´»åŠ¨å¯¹è±¡
        activeObjects.forEach(obj => {
            scene.remove(obj.css); scene.remove(obj.mesh); if(obj.ringMesh) scene.remove(obj.ringMesh); 
            if(obj.css.element && obj.css.element.parentNode) obj.css.element.parentNode.removeChild(obj.css.element);
        });
        activeObjects = [];

        // ==========================================
        // æ ¸å¿ƒä¿®æ”¹é€»è¾‘å¼€å§‹
        // ==========================================
        if (currentMode === 'collage') {
            // >>> æ‹¼è´´æ¨¡å¼æ–°é€»è¾‘ï¼šå…¨æ–‡æœ¬æ‰“æ•£ï¼ŒéšæœºæŠ½å– 9-12 è¡Œ <<<
            
            // 1. æå–æ‰€æœ‰è¯—æ­Œçš„æ‰€æœ‰è¡Œåˆ°å¤§æ± å­ä¸­
            let globalLinePool = [];
            allGroups.forEach(group => {
                // å°†æ¯ç»„çš„ lines æ‹¼æ¥åˆ°å¤§æ•°ç»„ä¸­
                globalLinePool = globalLinePool.concat(group.lines);
            });

            // 2. è®¡ç®—éšæœºæ•°é‡ (9 åˆ° 12 ä¹‹é—´)
            // Math.random() ç”Ÿæˆ 0-1ï¼Œä¹˜ä»¥ 4 å¾—åˆ° 0-3.99ï¼Œå‘ä¸‹å–æ•´ä¸º 0,1,2,3ï¼ŒåŠ  9 å¾—åˆ° 9,10,11,12
            const minLines = 9;
            const maxLines = 12;
            const randomCount = Math.floor(Math.random() * (maxLines - minLines + 1)) + minLines;

            // 3. å½»åº•ä¹±åºå¹¶å–å‰ randomCount ä¸ª
            const randomMixedLines = globalLinePool.sort(() => 0.5 - Math.random()).slice(0, randomCount);

            // 4. åŒ…è£…æˆ spawnTextAsteroids å‡½æ•°èƒ½è¯†åˆ«çš„æ ¼å¼
            activeGroups = [{
                id: 'collage_mixed_' + Date.now(), // éšæœºID
                lines: randomMixedLines
            }];

        } else {
            // >>> æ­£å¸¸æ¨¡å¼åŸé€»è¾‘ï¼šä¸¥æ ¼ä¿ç•™ï¼Œæœªåšä»»ä½•ä¿®æ”¹ <<<
            
            let availableGroups = [];
            if (finishedGroupIds.length >= allGroups.length) {
                this.showEndScreen();
                return;
            }
            availableGroups = allGroups.filter(g => !finishedGroupIds.includes(g.id));
            
            if(availableGroups.length === 0) {
                this.showEndScreen();
                return;
            }

            const count = Math.min(3, availableGroups.length);
            const shuffled = availableGroups.sort(() => 0.5 - Math.random());
            activeGroups = shuffled.slice(0, count);
        }
        // ==========================================
        // æ ¸å¿ƒä¿®æ”¹é€»è¾‘ç»“æŸ
        // ==========================================

        camera.position.set(0, 0, 0);
        camera.rotation.set(0, 0, 0);

        spawnTextAsteroids(activeGroups);
        
        // ä»…åœ¨æ­£å¸¸æ¨¡å¼ä¸‹æ›´æ–°è¿›åº¦æ¡
        if (currentMode === 'normal') updateProgressBar();
    },

    showNextRoundScreen: function() {
        const screen = document.getElementById('next-round-screen');
        screen.classList.remove('hidden');
    },

    showEndScreen: function() {
        const screen = document.getElementById('end-screen');
        document.getElementById('stats').textContent = `å…±æ”¶é›†è¯—æ­Œç¢ç‰‡ ${finishedGroupIds.length} ç»„`;
        screen.classList.remove('hidden');
    }
};

// ================= 5. 3D ç¯å¢ƒåˆå§‹åŒ– (ENGINE) =================
function init3D() {
    if (scene) return;
    const container = document.getElementById('canvas-container');
    const cssContainer = document.getElementById('css3d-container');
    scene = new THREE.Scene();
    // [Visual] å¢å¼ºé›¾æ°”
    scene.fog = new THREE.FogExp2(0x020205, 0.00025);
    
    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 25000);
    camera.position.set(0, 0, 0);
    renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.physicallyCorrectLights = true;
    renderer.outputEncoding = THREE.sRGBEncoding;
    container.appendChild(renderer.domElement);
    labelRenderer = new THREE.CSS3DRenderer();
    labelRenderer.setSize(window.innerWidth, window.innerHeight);
    labelRenderer.domElement.style.position = 'absolute';
    labelRenderer.domElement.style.top = '0';
    cssContainer.appendChild(labelRenderer.domElement);
    // [Visual] å¢å¼ºå…‰ç…§ç³»ç»Ÿ
    const ambientLight = new THREE.AmbientLight(0x4a4a4a, 2.5); 
    scene.add(ambientLight);
    const pointLight = new THREE.PointLight(0xffffff, 6.0, 2500);
    pointLight.position.set(200, 300, 400);
    scene.add(pointLight);
    const rimLight = new THREE.DirectionalLight(0xcceeff, 4.0); 
    rimLight.position.set(-1, 0.5, -0.5);
    scene.add(rimLight);
    
    // ... åŸæœ‰ä»£ç  ...
    createStarfield();
    // åˆå§‹åˆ›å»ºä¸€æ¬¡ï¼Œåç»­ç”± startLevel ç»´æŠ¤
    createBackgroundBelt(); 
    createSpaceDust(); // [æ–°å¢] åˆå§‹åŒ–å°˜åŸƒç³»ç»Ÿ
    
    // [ä¿®æ”¹] é¼ æ ‡ç›‘å¬ï¼šåŒæ—¶è®°å½•å½’ä¸€åŒ–åæ ‡(ç”¨äºç‚¹å‡»)å’Œå±å¹•åæ ‡(ç”¨äºæƒ¯æ€§)
    window.addEventListener('mousemove', (event) => {
        // 1. Raycaster ç”¨
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        
        // 2. é©¾é©¶èˆ±æƒ¯æ€§ç”¨
        mouseX = (event.clientX - windowHalfX);
        mouseY = (event.clientY - windowHalfY);
    });
    
    // ... åç»­ä»£ç  (window.addEventListener('click'... ) ä¿æŒä¸å˜ ...
    window.addEventListener('click', (event) => {
        if(isWarping) return;
        if (event.target.closest('#ui-layer') || event.target.closest('#ore-counter') || event.target.closest('#collection-modal') || event.target.closest('.btn-wrapper') || event.target.closest('.btn-inner') || event.target.closest('.hud-btn') || event.target.closest('#start-screen') || event.target.closest('.btn-small-wrapper') || event.target.closest('#end-download-section')) {
            return;
        }
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(activeObjects.map(o => o.mesh));
        if (intersects.length > 0) {
          
            const hitMesh = intersects[0].object;
            const targetObj = activeObjects.find(o => o.mesh === hitMesh);
            if (targetObj && targetObj.css.element.style.pointerEvents !== 'none') {
                const ud = targetObj.css.userData;
                const lineData = { txt: ud.text, idx: ud.lineIndex };
                
                // ç¡®ä¿è¿™é‡Œæœ‰è¿™ä¸€è¡Œè°ƒç”¨ï¼š
                SoundManager.playRockMetal();
                
                addToSlot(lineData, ud.groupId, targetObj.css);
            }
        }
    });
    window.addEventListener('resize', onWindowResize, false);
    animate();

    // ä¿®æ”¹ç‚¹ï¼šä¸º slot-area å¢åŠ  drop ç›‘å¬ï¼Œä»¥æ”¯æŒâ€œæ‹–æ‹½åˆ°æœ€ä¸‹æ–¹â€
    const slotContainer = document.getElementById('slot-area');
    if(slotContainer) {
        slotContainer.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'move'; });
        slotContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            // å¦‚æœç›®æ ‡æ˜¯ container æœ¬èº«ï¼ˆè¯´æ˜æ‹–åˆ°äº†ç©ºç™½å¤„ï¼‰ï¼Œåˆ™å°† item ç§»åŠ¨åˆ°æœ«å°¾
            if(e.target.id === 'slot-area' && dragSrcEl) {
                 const srcIndex = parseInt(dragSrcEl.dataset.index);
                 if(!isNaN(srcIndex) && srcIndex >= 0 && srcIndex < selectionSlot.length) {
                     const item = selectionSlot.splice(srcIndex, 1)[0];
                     selectionSlot.push(item);
                     setTimeout(() => { renderSlots(); checkCombination(); }, 0);
                 }
            }
        });
    }
}

window.onload = function() {
    init3D();
    WelcomeScene.init();
    AtmosphereManager.init(); // [æ–°å¢] å¯åŠ¨ç”Ÿæ€ç³»ç»Ÿ

    // [æ–°å¢] å…¨å±€äº¤äº’ç›‘å¬ï¼šç‚¹å‡»ä»»æ„ç©ºç™½å¤„ï¼ˆåŒ…æ‹¬æ¬¢è¿ç•Œé¢ï¼‰å¯åŠ¨/æ¢å¤ç¯å¢ƒéŸ³æ•ˆ
    const enableGlobalAudio = () => {
        // å¦‚æœæœªåˆå§‹åŒ–åˆ™åˆå§‹åŒ–ï¼Œå¦‚æœå·²æŒ‚èµ·åˆ™æ¢å¤
        SoundManager.init();
        if (SoundManager.ctx && SoundManager.ctx.state === 'suspended') {
            SoundManager.ctx.resume();
        }
    };
    // ç›‘å¬ç‚¹å‡»å’Œè§¦æ‘¸ï¼Œç¡®ä¿ç§»åŠ¨ç«¯ä¹Ÿèƒ½ç”Ÿæ•ˆ
    document.addEventListener('click', enableGlobalAudio);
    document.addEventListener('touchstart', enableGlobalAudio);
}

// [Visual] ç§»æ¤ v5.6 çš„å¤šå±‚çº§æ˜Ÿç©º (å¯†åº¦å¢åŠ 30% + å¤§äº®æ˜Ÿ)
function createStarfield() {
    if(starField) scene.remove(starField);
    starField = new THREE.Group();
    const getGlowTexture = () => {
        const canvas = document.createElement('canvas');
        canvas.width = 32;
        canvas.height = 32;
        const ctx = canvas.getContext('2d');
        const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
        grad.addColorStop(0, 'rgba(255, 255, 255, 1)'); grad.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)'); grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)'); grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
        ctx.fillStyle = grad; ctx.fillRect(0, 0, 32, 32);
        return new THREE.CanvasTexture(canvas);
    };
    const glowTex = getGlowTexture();
    // [Logic Change] å¢åŠ æ˜Ÿæ˜Ÿæ•°é‡ (å¯†åº¦å¢åŠ  ~40%)
    const starTypes = [ 
        { count: 45000, size: 15, opacity: 0.3, colors: [0x556677, 0x334455, 0x222222] }, 
        { count: 30000, size: 35, opacity: 0.4, colors: [0x440066, 0x003366, 0x660033, 0x110033] }, 
        { count: 20000, size: 45, opacity: 0.8, colors: [0xffffff, 0xffffee, 0xffddcc] }, 
        { count: 1800, size: 90, opacity: 0.9, colors: [0xff4422, 0xff8844, 0xff6633] }, 
      
        { count: 850, size: 60, opacity: 1.0, colors: [0xaaccff, 0xccddff, 0xffffff] },
        { count: 360, size: 180, opacity: 1.0, colors: [0xffffff, 0xaaddff] },
{ 
    count: 6,               // æ•°é‡æå°‘ (5-10ä¸ªå³å¯)
    size: 1000 + Math.random() * 2000,             // å°ºå¯¸æå¤§ (å½¢æˆå¼¥æ•£çš„å…‰æ™•)
    opacity: 0.2,          // é€æ˜åº¦æä½ (æœ¦èƒ§æ„Ÿï¼Œä¸æŠ¢çœ¼)
    colors: [0x4b0082, 0x800080, 0x00008b, 0xff1493] // æ˜Ÿäº‘è‰²ï¼šæ·±ç´«ã€ç´«ç½—å…°ã€æ·±è“ã€æ·±ç²‰
}
    ];
    // [Logic Change] æè¿œæ™¯æ˜Ÿç©º -5000 åˆ° -7000
    const Z_NEAR = -5000; const Z_FAR = -6000;
    starTypes.forEach(type => {
        const geo = new THREE.BufferGeometry(); const pos = []; const cols = [];
        for(let i=0; i<type.count; i++) {
            const x = (Math.random() - 0.5) * 50000; const y = (Math.random() - 0.5) * 30000; const z = Z_FAR + Math.random() * (Z_NEAR - Z_FAR);
            pos.push(x, y, z);
            const color = 
            new THREE.Color(); const cHex = type.colors[Math.floor(Math.random() * type.colors.length)];
            color.setHex(cHex); color.multiplyScalar(0.8 + Math.random() * 0.4); cols.push(color.r, color.g, color.b);
        }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
        geo.setAttribute('color', new THREE.Float32BufferAttribute(cols, 3));
        const mat = new THREE.PointsMaterial({ size: type.size, map: glowTex, transparent: true, opacity: type.opacity, vertexColors: true, blending: THREE.AdditiveBlending, depthWrite: false, fog: false });
        starField.add(new THREE.Points(geo, mat));
    });
    scene.add(starField);
}

// [Visual] ç§»æ¤ v5.6 çš„é«˜çº§çº¹ç†ç”Ÿæˆå™¨
function createAsteroidMaps(style = 0) {
    const size = 512;
    const canvas = document.createElement('canvas'); canvas.width = size; canvas.height = size; const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#808080';
    ctx.fillRect(0, 0, size, size);
    for (let i = 0; i < 60000; i++) { const val = Math.floor(Math.random() * 60 + 90);
    ctx.fillStyle = `rgba(${val},${val},${val}, 0.5)`; ctx.fillRect(Math.random() * size, Math.random() * size, 2, 2);
    }
    if (style === 0) { for (let i = 0; i < 25; i++) { const x = Math.random() * size;
    const y = Math.random() * size; const r = 5 + Math.random() * 35;
    const g = ctx.createRadialGradient(x, y, r * 0.1, x, y, r); g.addColorStop(0, '#333333'); g.addColorStop(0.8, '#666666'); g.addColorStop(1, 'rgba(100,100,100,0)'); ctx.fillStyle = g;
    ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fill(); ctx.strokeStyle = 'rgba(200,200,200,0.1)'; ctx.lineWidth = 1; ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2); ctx.stroke(); } } 
    else if (style === 1) { for(let i=0; i<40; i++) { const y = Math.random() * size;
    const h = Math.random() * 20 + 5; ctx.fillStyle = `rgba(30, 30, 30, ${Math.random() * 0.3})`; ctx.fillRect(0, y, size, h);
    ctx.beginPath(); ctx.moveTo(0, y + h/2); ctx.lineTo(size, y + h/2 + (Math.random()-0.5)*20); ctx.strokeStyle = `rgba(0,0,0,0.4)`; ctx.stroke();
    } }
    else if (style === 2) { for(let i=0; i<150; i++) { ctx.beginPath();
    ctx.moveTo(Math.random() * size, Math.random() * size); ctx.lineTo(Math.random() * size, Math.random() * size); ctx.lineTo(Math.random() * size, Math.random() * size);
    ctx.fillStyle = `rgba(20, 20, 20, ${Math.random() * 0.4})`; ctx.fill(); } }
    else if (style === 3) { for(let i=0; i<100; i++) { ctx.beginPath();
    const x1 = Math.random() * size; const y1 = Math.random() * size; const len = Math.random() * 100 + 20;
    const ang = Math.random() * Math.PI * 2; ctx.moveTo(x1, y1); ctx.lineTo(x1 + Math.cos(ang)*len, y1 + Math.sin(ang)*len);
    ctx.lineWidth = Math.random() * 2 + 0.5; ctx.strokeStyle = `rgba(20, 20, 20, ${Math.random() * 0.6})`; ctx.stroke();
    } }
    else if (style === 4) { ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; ctx.lineWidth = 1.5;
    for(let i=0; i<30; i++) { ctx.beginPath(); let x = Math.random() * size; let y = Math.random() * size; ctx.moveTo(x, y);
    for(let j=0; j<5; j++) { x += (Math.random() - 0.5) * 100; y += (Math.random() - 0.5) * 100;
    ctx.lineTo(x, y); } ctx.stroke(); } }
    else if (style === 5) { for (let i = 0; i < 20000; i++) { const val = Math.floor(Math.random() * 40 + 30);
    ctx.fillStyle = `rgba(${val},${val},${val}, 0.2)`; const r = Math.random() * 3 + 1; ctx.beginPath();
    ctx.arc(Math.random() * size, Math.random() * size, r, 0, Math.PI*2); ctx.fill();
    } }
    else if (style === 6) { for (let i = 0; i < 80000; i++) { const val = Math.floor(Math.random() * 100);
    ctx.fillStyle = `rgba(${val},${val},${val}, 0.4)`; ctx.fillRect(Math.random() * size, Math.random() * size, 2, 2);
    } }
    else if (style === 7) { ctx.fillStyle = '#333'; ctx.fillRect(0,0,size,size);
    for(let i=0; i<500; i++) { const r = Math.random() * 8 + 2; ctx.beginPath(); ctx.arc(Math.random()*size, Math.random()*size, r, 0, Math.PI*2);
    ctx.fillStyle = 'rgba(0,0,0,0.8)'; ctx.fill(); } }
    else if (style === 8) { for(let i=0; i<10000; i++) { const x = Math.random() * size;
    const y = Math.random() * size; const w = Math.random() * 10; const h = Math.random() * 5;
    ctx.fillStyle = `rgba(40,40,40, ${Math.random() * 0.5})`; ctx.fillRect(x, y, w, h);
    } }
    else if (style === 9) { for(let i=0; i<50; i++) { const x = Math.random() * size;
    const y = Math.random() * size; const r = Math.random() * 80 + 20; const g = ctx.createRadialGradient(x,y,0,x,y,r); g.addColorStop(0, 'rgba(60,30,10,0.6)');
    g.addColorStop(1, 'rgba(60,30,10,0)'); ctx.fillStyle = g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); } }
    else if (style === 10) { ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgba(200,200,200,0.2)'; for(let i=0; i<200; i++) { const angle = (Math.floor(Math.random()*3) * 60) * Math.PI / 180;
    const x = Math.random() * size; const y = Math.random() * size; const len = size; ctx.beginPath();
    ctx.moveTo(x - Math.cos(angle)*len, y - Math.sin(angle)*len); ctx.lineTo(x + Math.cos(angle)*len, y + Math.sin(angle)*len); ctx.stroke();
    } }
    
    const baseMap = new THREE.CanvasTexture(canvas);
    const imgData = ctx.getImageData(0, 0, size, size); const data = imgData.data; const normalCanvas = document.createElement('canvas'); normalCanvas.width = size;
    normalCanvas.height = size; const normalCtx = normalCanvas.getContext('2d'); const normalImgData = normalCtx.createImageData(size, size); const nData = normalImgData.data;
    for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
            const idx = (y * size + x) * 4;
            const r = data[idx];
            const xR = (x + 1 < size) ?
            data[((y * size + x + 1) * 4)] : r; const xL = (x - 1 >= 0) ?
            data[((y * size + x - 1) * 4)] : r; const yB = (y + 1 < size) ?
            data[(((y + 1) * size + x) * 4)] : r; const yT = (y - 1 >= 0) ?
            data[(((y - 1) * size + x) * 4)] : r;
            const dx = (xR - xL) / 255.0;
            const dy = (yB - yT) / 255.0;
            let dz = 0.8; if (style === 3) dz = 0.3;
            if (style === 7) dz = 0.5; if (style === 8) dz = 0.4; 
            let nx = -dx;
            let ny = -dy; let nz = dz; const len = Math.sqrt(nx * nx + ny * ny + nz * nz);
            nData[idx] = (nx / len * 0.5 + 0.5) * 255;
            nData[idx + 1] = (ny / len * 0.5 + 0.5) * 255;
            nData[idx + 2] = (nz / len * 0.5 + 0.5) * 255; nData[idx + 3] = 255;
            }
    }
    normalCtx.putImageData(normalImgData, 0, 0); const normalMap = new THREE.CanvasTexture(normalCanvas);
    const roughCanvas = document.createElement('canvas');
    roughCanvas.width = size; roughCanvas.height = size; const roughCtx = roughCanvas.getContext('2d');
    let baseRough = '#cccccc';
    if (style === 3) baseRough = '#444444'; if (style === 4) baseRough = '#222222';
    if (style === 10) baseRough = '#666666'; 
    roughCtx.fillStyle = baseRough; roughCtx.fillRect(0, 0, size, size);
    let shineCount = 300;
    if (style === 2 || style === 3 || style === 6) shineCount = 600;
    if (style === 7 || style === 9) shineCount = 50;
    for(let i=0; i<shineCount; i++) { const x = Math.random() * size; const y = Math.random() * size;
    const w = Math.random() * 15; const h = Math.random() * 15;
    let spotColor = `rgba(30, 30, 30, ${Math.random() * 0.6})`; if (style === 5) spotColor = `rgba(180, 180, 180, 0.1)`;
    roughCtx.fillStyle = spotColor; roughCtx.fillRect(x, y, w, h); }
    const roughnessMap = new THREE.CanvasTexture(roughCanvas);
    return { baseMap, normalMap, roughnessMap };
}

// [Visual] ç§»æ¤ v5.6 çš„å‡ ä½•ä½“ç½®æ¢
function modifyAsteroidGeometry(geometry, radius) {
    const posAttribute = geometry.attributes.position;
    const vertex = new THREE.Vector3(); const count = posAttribute.count;
    const seed = Math.random() * 100;
    const amp1 = radius * (0.3 + Math.random() * 0.4); 
    const lumps = [];
    const numLumps = 2 + Math.floor(Math.random() * 3);
    for(let k=0; k<numLumps; k++) { lumps.push({ x: Math.random()-0.5, y: Math.random()-0.5, z: Math.random()-0.5, strength: 0.2 + Math.random() * 0.3, width: 1.5 + Math.random() });
    }
    const craters = []; const numCraters = 1 + Math.floor(Math.random() * 2);
    for(let k=0; k<numCraters; k++) { craters.push({ x: Math.random()-0.5, y: Math.random()-0.5, z: Math.random()-0.5, strength: 0.1 + Math.random() * 0.1, width: 3.0 + Math.random() * 2.0 });
    }
    const scaleX = 0.8 + Math.random() * 0.4; const scaleY = 0.8 + Math.random() * 0.4;
    const scaleZ = 0.8 + Math.random() * 0.4;
    for (let i = 0; i < count; i++) {
        vertex.fromBufferAttribute(posAttribute, i);
        vertex.normalize(); 
        let r = radius;
        const noise1 = Math.sin(vertex.x * 2.5 + seed) * Math.cos(vertex.y * 2.5 + seed) * Math.sin(vertex.z * 2.5 + seed);
        r += noise1 * amp1;
        for(let l of lumps) { const dot = vertex.x * l.x + vertex.y * l.y + vertex.z * l.z;
        if(dot > 0) r += Math.pow(dot, l.width) * radius * l.strength;
        }
        for(let c of craters) { const dot = vertex.x * c.x + vertex.y * c.y + vertex.z * c.z;
        if(dot > 0.8) r -= Math.pow(dot, c.width) * radius * c.strength; }
        vertex.multiplyScalar(r);
        vertex.x *= scaleX; vertex.y *= scaleY; vertex.z *= scaleZ;
        posAttribute.setXYZ(i, vertex.x, vertex.y, vertex.z);
    }
    geometry.computeVertexNormals();
}

function clearBackgroundBelt() {
    if (!bgGroup) return;
    bgGroup.children.forEach(child => { if (child.geometry) child.geometry.dispose(); if (child.material) child.material.dispose(); });
    scene.remove(bgGroup);
    bgGroup = null;
}

// [Visual] ç§»æ¤ v5.6 çš„ InstancedMesh èƒŒæ™¯å¸¦ + [Logic] Zè½´èŒƒå›´ä¿®æ”¹ [-1500, -6000] + æ•°é‡å¢åŠ  + ç¢°æ’æ•°æ®è®°å½•
function createBackgroundBelt() {
    bgGroup = new THREE.Group();
    // [Change] å¢åŠ æ•°é‡ä»¥å¡«å……æ›´å¤§ç©ºé—´
    const totalCount = 4500; 
    const variants = 5; const countPerVariant = Math.ceil(totalCount / variants);
    const occupiedSpaces = [];
    bgAsteroidsData = []; // Reset Global Data

    const bgStyle = Math.floor(Math.random() * 11);
    const maps = createAsteroidMaps(bgStyle);
    const bgGray = 0.3 + Math.random() * 0.4; const bgColor = new THREE.Color().setHSL(0, 0, bgGray);
    let metalness = 0.1; if (bgStyle === 3) metalness = 0.8; if (bgStyle === 4) metalness = 0.4;
    if (bgStyle === 8) metalness = 0.7; if (bgStyle === 10) metalness = 0.9;
    const baseMaterial = new THREE.MeshStandardMaterial({ map: maps.baseMap, normalMap: maps.normalMap, normalScale: new THREE.Vector2(2, 2), roughnessMap: maps.roughnessMap, roughness: 1.0, metalness: metalness, color: bgColor, transparent: false, opacity: 1.0 });
    baseMaterial.onBeforeCompile = (shader) => {
        shader.uniforms.time = { value: 0 };
        baseMaterial.userData.shader = shader;
        shader.vertexShader = 'uniform float time;\n' + shader.vertexShader;
        shader.vertexShader = shader.vertexShader.replace('#include <begin_vertex>', `vec3 transformed = vec3( position ); float randomOffset = sin(instanceMatrix[3].x * 0.01 + instanceMatrix[3].z * 0.01); float floatY = sin(time * 0.2 + randomOffset * 10.0) * 5.0; float floatX = cos(time * 0.15 + randomOffset * 10.0) * 5.0; transformed.y += floatY; transformed.x += floatX;`);
    };
    const dummy = new THREE.Object3D();
    for (let v = 0; v < variants; v++) {
        const baseRadius = 10;
        const geometry = new THREE.IcosahedronGeometry(baseRadius, 2); modifyAsteroidGeometry(geometry, baseRadius);
        const mesh = new THREE.InstancedMesh(geometry, baseMaterial, countPerVariant);
        let validCount = 0;
        for (let i = 0; i < countPerVariant; i++) {
            let attempts = 0;
            let placed = false; let x, y, z, s, currentRadius;
            while (!placed && attempts < 10) {
                const r = Math.random();
                // [Logic] åŸå§‹éšæœºå¤§å°ç”Ÿæˆ
                if (r > 0.90) s = 20.0 + Math.random() * 30.0;
                else if (r > 0.70) s = 8.0 + Math.random() * 15.0; 
                else s = 1.0 + Math.random() * 7.0;
                const theta = Math.random() * Math.PI * 2; const dist = 4000 + Math.random() * 8000;
                x = Math.cos(theta) * dist; 
                
                // [Logic Change] Zè½´èŒƒå›´: -1200 åˆ° -4500 (æ­¤å¤„ä¿æŒåŸæœ‰ç”Ÿæˆé€»è¾‘)
                z = -1200 - Math.random() * 3300;
                // --- NEW LOGIC: é˜²ç©¿æ¨¡å°ºå¯¸é™åˆ¶ ---
                // å¦‚æœ Z è½´ä½äº -1200 åˆ° -1600 ä¹‹é—´ï¼ˆé è¿‘å‰æ™¯è¯—æ­ŒåŒºï¼‰
                if (z > -1600) {
                    // å¼ºåˆ¶å°†æœ€å¤§ç¼©æ”¾é™åˆ¶åœ¨ 6.0 ä»¥å†… (çº¦åŠå¾„ 60)ï¼Œé¿å…å·¨å¤§çš„å²©çŸ³é®æŒ¡æ–‡å­—
                    s = Math.min(s, 6.0);
                }
                
                y = (Math.random() - 0.5) * 8000;
                currentRadius = baseRadius * s; // é‡æ–°è®¡ç®—åŠå¾„

                let collision = false;
                for (let j = 0; j < occupiedSpaces.length; j++) { const other = occupiedSpaces[j]; const dx = x - other.x;
                const dy = y - other.y; const dz = z - other.z; const distSq = dx*dx + dy*dy + dz*dz;
                const minDist = (currentRadius + other.radius) * 1.5; if (distSq < minDist * minDist) { collision = true; break;
                } }
                if (!collision) placed = true;
                attempts++;
            }
            if (placed) { 
                dummy.position.set(x, y, z);
                dummy.rotation.set(Math.random() * Math.PI, Math.random() * Math.PI, Math.random() * Math.PI); dummy.scale.set(s, s, s); dummy.updateMatrix(); mesh.setMatrixAt(validCount, dummy.matrix);
                occupiedSpaces.push({ x: x, y: y, z: z, radius: currentRadius });
                // [ADD] Store for collision check with text
                bgAsteroidsData.push({ x: x, y: y, z: z, r: currentRadius });
                validCount++; 
            } 
            else { dummy.position.set(0, 100000, 0);
            dummy.scale.set(0, 0, 0); dummy.updateMatrix(); mesh.setMatrixAt(i, dummy.matrix); }
        }
        bgGroup.add(mesh);
    }
    bgGroup.rotation.x = Math.PI / 30; bgGroup.rotation.z = Math.PI / 30; scene.add(bgGroup);
}

// --- æ–°å¢ï¼šå½—æ˜Ÿç³»ç»Ÿ ---
function spawnComet() {
    // å½—æ˜Ÿå¤´éƒ¨
    const headGeo = new THREE.SphereGeometry(15, 8, 8);
    const mat = new THREE.MeshBasicMaterial({ color: 0xaaccff, transparent: true, opacity: 0.9 });
    const mesh = new THREE.Mesh(headGeo, mat);
    // å½—æ˜Ÿå°¾éƒ¨ (åœ†é”¥ä½“)
    const tailGeo = new THREE.ConeGeometry(15, 300, 8, 1, true);
    tailGeo.rotateX(Math.PI / 2);
    tailGeo.translate(0, 0, 150); 
    const tailMat = new THREE.MeshBasicMaterial({ color: 0x4466aa, transparent: true, opacity: 0.4, blending: THREE.AdditiveBlending, depthWrite: false });
    const tail = new THREE.Mesh(tailGeo, tailMat);
    mesh.add(tail);

    // éšæœºä½ç½®ï¼šZè½´ -2000 åˆ° -3000
    const startZ = -2000 - Math.random() * 1000;
    const startY = (Math.random() - 0.5) * 3000;
    // Xè½´ï¼šä»å±å¹•å¤–ä¾§é£å…¥
    const startX = (Math.random() > 0.5 ? 1 : -1) * 5000;
    mesh.position.set(startX, startY, startZ);
    
    const targetX = (Math.random() - 0.5) * 1000;
    const targetY = (Math.random() - 0.5) * 500;
    const dx = targetX - startX;
    const dy = targetY - startY;
    const angle = Math.atan2(dy, dx);
    const speed = 30 + Math.random() * 20; 
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    const vz = (Math.random() - 0.5) * 5; 

    mesh.rotation.y = -angle; 
    scene.add(mesh);
    comets.push({ mesh: mesh, vx: vx, vy: vy, vz: vz });
}

function updateComets() {
    for (let i = comets.length - 1; i >= 0; i--) {
        const c = comets[i];
        c.mesh.position.x += c.vx;
        c.mesh.position.y += c.vy;
        c.mesh.position.z += c.vz;
        
        c.mesh.children[0].scale.x = 1 + Math.sin(Date.now() * 0.02) * 0.2;
        c.mesh.children[0].scale.y = 1 + Math.cos(Date.now() * 0.02) * 0.2;

        if (Math.abs(c.mesh.position.x) > 6000 || Math.abs(c.mesh.position.y) > 4000) {
            scene.remove(c.mesh);
            if(c.mesh.geometry) c.mesh.geometry.dispose();
            if(c.mesh.material) c.mesh.material.dispose();
            if(c.mesh.children[0]) { c.mesh.children[0].geometry.dispose(); c.mesh.children[0].material.dispose(); }
            comets.splice(i, 1);
        }
    }
    if (comets.length < 2 && Math.random() < 0.005) { spawnComet();
    }
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight); labelRenderer.setSize(window.innerWidth, window.innerHeight);
}

// ================= 6. æ¸¸æˆå†…ç‰©ä½“é€»è¾‘ (GAMEPLAY) =================

function generateSoftColor() {
    const h = Math.floor(Math.random() * 360);
    const s = Math.floor(Math.random() * 30) + 30; const l = Math.floor(Math.random() * 25) + 50; 
    return `hsl(${h}, ${s}%, ${l}%)`;
}

function createTextRingTexture(text, color) {
    const canvas = document.createElement('canvas'); canvas.width = 1024; canvas.height = 128;
    const ctx = canvas.getContext('2d');
    ctx.font = "bold 60px 'PingFang SC', sans-serif"; ctx.fillStyle = color; ctx.textAlign = "center"; ctx.textBaseline = "middle";
    ctx.shadowColor = color; ctx.shadowBlur = 15; ctx.fillText(text, 512, 64);
    const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; return texture;
}

// ========== æ¤­åœ†åˆ†å¸ƒç”Ÿæˆé€»è¾‘ (é€»è¾‘ä¿ç•™ + Zè½´èŒƒå›´ä¿®æ”¹ + å››è§’æ£€æµ‹ + è§†è§‰å¢å¼º) ==========
function spawnTextAsteroids(groups) {
    groups.forEach((group, gIndex) => {
        const linesToSpawn = [...group.lines].sort(() => 0.5 - Math.random());
        linesToSpawn.forEach((lineObj, lIndex) => {
            const div = document.createElement('div'); div.className = 'asteroid-card'; div.textContent = lineObj.txt; div.style.fontSize = '24px'; 
            const objectCSS = new THREE.CSS3DObject(div);
            
            // [Visual] ä½¿ç”¨ v5.6 çš„é«˜ç²¾åº¦é™¨çŸ³ç”Ÿæˆå‚æ•°
            const radius = 25 + Math.random() * 15; 
            const geometry = new THREE.IcosahedronGeometry(radius, 4); modifyAsteroidGeometry(geometry, radius);
            const randomStyle = Math.floor(Math.random() * 11); const maps = createAsteroidMaps(randomStyle);
            const randomLightness = 0.05 + Math.random() * 0.35; const randomColor = new THREE.Color().setHSL(0, 0, 
            randomLightness);
            let metalness = 0.2; if (randomStyle === 3) metalness = 0.8;
            const material = new THREE.MeshStandardMaterial({ map: maps.baseMap, normalMap: maps.normalMap, normalScale: new THREE.Vector2(1.5, 1.5), roughnessMap: maps.roughnessMap, roughness: 1.0, metalness: metalness, color: randomColor });
            const mesh = new THREE.Mesh(geometry, material);
            
            // [Visual] ä½¿ç”¨ v5.6 çš„å¤§å°ºå¯¸æ–‡å­—ç¯
            const ringRadius = radius * 2.2;
            const ringHeight = 50; const ringGeo = new THREE.CylinderGeometry(ringRadius, ringRadius, ringHeight, 32, 1, true);
            const ringMat = new THREE.MeshBasicMaterial({ map: createTextRingTexture(lineObj.txt, currentRingColor), transparent: true, opacity: 0.9, side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite: false });
            const ringMesh = new THREE.Mesh(ringGeo, ringMat);

            let attempts = 0; let validPosition = false; let x, y, z;
            while (!validPosition && attempts < 50) {
                
                // [Logic Change] Zè½´èŒƒå›´: -300 åˆ° -1000
                z = -300 - Math.random() * 700;
                const vFOV = THREE.Math.degToRad(camera.fov); const dist = Math.abs(z - camera.position.z);
                const visibleHeight = 2 * Math.tan(vFOV / 2) * dist;
                const visibleWidth = visibleHeight * camera.aspect;
                
                // [Logic Change] Xè½´èŒƒå›´æ‰©å¤§ï¼Œè¾¹è·å¢åŠ åˆ° 80 (å¤§å¹…æ‰©å¤§)
                const marginX = 80;
                const marginY = 100; 
                const a = Math.max(0, (visibleWidth / 2) - marginX);
                const b = Math.max(0, (visibleHeight / 2) - marginY); 
                const theta = Math.random() * Math.PI * 2;
                const r = Math.sqrt(Math.random()); 
                x = a * r * Math.cos(theta); y = b * r * Math.sin(theta);
                // [Logic Change] æ™ºèƒ½å››è§’æ£€æµ‹
                const xPct = x / (visibleWidth / 2);
                // -1 åˆ° 1
                const yPct = y / (visibleHeight / 2);
                // -1 åˆ° 1 (æ³¨æ„ y å‘ä¸Šä¸ºæ­£)
                
                let inCorner = false;
                // å·¦ä¸Š (è®¡æ•°å™¨): x < -0.6, y > 0.6
                if (xPct < -0.6 && yPct > 0.6) inCorner = true;
                // å³ä¸Š (è¿›åº¦æ¡): x > 0.6, y > 0.7
                if (xPct > 0.6 && yPct > 0.7) inCorner = true;
                // å·¦ä¸‹ (å¤‡é€‰æ ): x < -0.6, y < -0.6
                if (xPct < -0.6 && yPct < -0.6) inCorner = true;
                // å³ä¸‹ (æŒ‰é’®ç»„): x > 0.6, y < -0.5
                if (xPct > 0.6 && yPct < -0.5) inCorner = true;
                let tooClose = false;
                for (let other of activeObjects) { const dx = x - other.css.position.x;
                const dy = y - other.css.position.y; const dz = z - other.css.position.z; const d = Math.sqrt(dx*dx + dy*dy + dz*dz);
                if (d < 320) { tooClose = true; break; } }
                
                // [ADD] Check against background asteroids
                if (!tooClose) {
                    for (let bg of bgAsteroidsData) {
          
                        // Pre-filter by Z depth (optimization)
                        if (Math.abs(z - bg.z) > 200) continue;
                        const dx = x - bg.x; const dy = y - bg.y; const dz = z - bg.z;
                        const dSq = dx*dx + dy*dy + dz*dz;
                        // Safe distance = text radius + asteroid radius + buffer
                        const safeDist = radius + bg.r + 100;
                        if (dSq < safeDist * safeDist) {
                            tooClose = true;
                            break;
                        }
                    }
                }
                
                if (!tooClose && !inCorner) validPosition = true;
                attempts++;
            }

            objectCSS.position.set(x, y, z);
            mesh.position.set(x - 40, y, z - 20); ringMesh.position.copy(mesh.position); 
            ringMesh.rotation.x = (Math.random() - 0.5) * 0.5;
            ringMesh.rotation.z = (Math.random() - 0.5) * 0.5;

            const rotSpeed = { x: (Math.random() - 0.5) * 0.02, y: (Math.random() - 0.5) * 0.02, z: (Math.random() - 0.5) * 0.02 };
            const floatParams = { originPos: objectCSS.position.clone(), floatSpeed: 0.0002 + Math.random() * 0.0012, floatPhase: Math.random() * Math.PI * 2, floatAmp: 20 + Math.random() * 40, floatAmpX: 20 + Math.random() * 40, floatPhaseX: Math.random() * Math.PI * 2, floatAmpZ: 5 + Math.random() * 15, floatPhaseZ: Math.random() * Math.PI * 2, ringRotSpeed: 0.01 + Math.random() * 0.02 };
            objectCSS.userData = { text: lineObj.txt, groupId: group.id, lineIndex: lineObj.idx, isHovered: false, linkedMesh: mesh, linkedRing: ringMesh, rotSpeed: rotSpeed, ...floatParams };
            const animateEnter = () => {
                if (objectCSS.userData.isHovered) return;
                // --- æ–°å¢ä»£ç : æ‚¬åœéŸ³æ•ˆæ”¹ä¸ºä¹¦é¡µå£° ---
                SoundManager.playPageTurn();
                // ---------------------------------
                objectCSS.userData.isHovered = true; div.classList.add('active-reading');
                new TWEEN.Tween(ringMesh.material).to({ opacity: 0 }, 200).start();
                new TWEEN.Tween(mesh.scale).to({ x: 1.2, y: 1.2, z: 1.2 }, 300).easing(TWEEN.Easing.Quadratic.Out).start();
                objectCSS.lookAt(camera.position); new TWEEN.Tween(objectCSS.scale).to({ x: 1.5, y: 1.5, z: 1.5 }, 300).start();
            };
            const animateLeave = () => {
                if (!objectCSS.userData.isHovered) return;
                objectCSS.userData.isHovered = false; div.classList.remove('active-reading');
                new TWEEN.Tween(ringMesh.material).to({ opacity: 0.9 }, 300).start();
                new TWEEN.Tween(mesh.scale).to({ x: 1, y: 1, z: 1 }, 300).easing(TWEEN.Easing.Quadratic.Out).start();
                new TWEEN.Tween(objectCSS.scale).to({ x: 1, y: 1, z: 1 }, 300).start();
            };
            objectCSS.userData.onEnter = animateEnter; objectCSS.userData.onLeave = animateLeave;
            // [ä¿®æ”¹ 1/2] å¢åŠ  DOM æ‚¬åœæ ‡è®°ï¼Œå‘Šè¯‰å°„çº¿æ£€æµ‹â€œåˆ«å…³æˆ‘â€
            div.addEventListener('mouseenter', () => { 
                if (objectCSS.element.style.pointerEvents === 'none') return; 
                objectCSS.userData.isDomHovered = true; // æ ‡è®°ï¼šé¼ æ ‡åœ¨æ–‡å­—ä¸Š
                animateEnter(); 
            });
            div.addEventListener('mouseleave', () => { 
                if (objectCSS.element.style.pointerEvents === 'none') return; 
                objectCSS.userData.isDomHovered = false; // æ ‡è®°ï¼šé¼ æ ‡ç¦»å¼€æ–‡å­—äº†
                animateLeave(); 
            });
            div.addEventListener('pointerdown', (e) => { 
                 e.stopPropagation(); 
                 if (objectCSS.element.style.pointerEvents !== 'none') {
                    // æ–°å¢ï¼šæ’­æ”¾å²©çŸ³æ’å‡»é‡‘å±éŸ³æ•ˆ
                    SoundManager.playRockMetal();
                    addToSlot(lineObj, group.id, objectCSS); 
                 }
            });

            scene.add(objectCSS); scene.add(mesh); scene.add(ringMesh);
            activeObjects.push({ css: objectCSS, mesh: mesh, ringMesh: ringMesh });
            objectCSS.scale.set(0,0,0); mesh.scale.set(0,0,0); ringMesh.scale.set(0,0,0);
            const delay = Math.random() * 500;
            new TWEEN.Tween(objectCSS.scale).to({x: 1, y: 1, z: 1}, 800).easing(TWEEN.Easing.Back.Out).delay(delay).start();
            new TWEEN.Tween(mesh.scale).to({x: 1, y: 1, z: 1}, 800).easing(TWEEN.Easing.Back.Out).delay(delay).start();
            new TWEEN.Tween(ringMesh.scale).to({x: 1, y: 1, z: 1}, 800).easing(TWEEN.Easing.Back.Out).delay(delay).start();
        });
    });
}

function addToSlot(lineData, groupId, cssObject) {
    if (isWarping) return;
    if (selectionSlot.length >= MAX_SLOTS) { showToast("å­˜å‚¨æ§½å·²æ»¡ï¼Œè¯·ç§»é™¤", "warning"); return;
    }
    
    // åœæ­¢å…±é¸£åŠ¨ç”»
    if(cssObject.userData.resonanceTween) {
        cssObject.userData.resonanceTween.stop();
        cssObject.userData.resonanceMeshTween.stop(); cssObject.userData.resonanceEmissiveTween.stop();
        cssObject.userData.linkedMesh.material.emissive.setHex(0x000000);
    }
    
    const mesh = cssObject.userData.linkedMesh; const ring = cssObject.userData.linkedRing;
    cssObject.element.style.pointerEvents = 'none'; cssObject.userData.isHovered = false; cssObject.element.classList.remove('active-reading');
    
    selectionSlot.push({ txt: lineData.txt, idx: lineData.idx, groupId: groupId, originalObj: cssObject });

    // [æ–°å¢] æ£€æŸ¥é€»è¾‘ï¼šå¦‚æœå½“å‰æ”¶é›†çš„ç¢ç‰‡å±äºæ­£åœ¨æç¤ºçš„ç»„ï¼Œä¸”è¯¥ç»„å·²å…¨éƒ¨é›†é½
    if (currentHintGroupId && currentHintGroupId === groupId) {
        const groupData = allGroups.find(g => g.id === groupId);
        if (groupData) {
            // è®¡ç®—å¤‡é€‰æ ä¸­è¯¥ç»„ç¢ç‰‡çš„æ•°é‡
            const collectedCount = selectionSlot.filter(item => item.groupId === groupId).length;
            // å¦‚æœæ•°é‡ç­‰äºè¯¥ç»„åŸæœ¬çš„æ€»è¡Œæ•°
            if (collectedCount === groupData.lines.length) {
                // ç«‹å³åœæ­¢å‘¼å¸éŸ³æ•ˆå’Œè§†è§‰é«˜äº® (SoundManagerå†…éƒ¨æœ‰0.5sæ·¡å‡ºï¼Œä¸ä¼šçªå…€)
                stopResonance(groupId);
                showToast("å…±é¸£çŸ¿çŸ³å·²æ•è·", "success");
            }
        }
    }

    new TWEEN.Tween(cssObject.scale).to({x: 0, y: 0, z: 0}, 300).start();
    new TWEEN.Tween(mesh.scale).to({x: 0, y: 0, z: 0}, 300).start();
    new TWEEN.Tween(ring.scale).to({x: 0, y: 0, z: 0}, 300).onComplete(() => {
        scene.remove(cssObject); scene.remove(mesh); scene.remove(ring);
        if (cssObject.element && cssObject.element.parentNode) cssObject.element.parentNode.removeChild(cssObject.element);
        const idx = activeObjects.findIndex(item => item.css === cssObject);
        if (idx > -1) activeObjects.splice(idx, 1);
    }).start();
    if(hoveredObject && hoveredObject.css === cssObject) hoveredObject = null;
    renderSlots();
    checkCombination();
}

function removeFromSlot(index) {
    const item = selectionSlot[index];
    selectionSlot.splice(index, 1);
    const cssObject = item.originalObj;
    const mesh = cssObject.userData.linkedMesh; const ring = cssObject.userData.linkedRing; 

    document.getElementById('css3d-container').appendChild(cssObject.element);
    scene.add(cssObject); scene.add(mesh); scene.add(ring);
    activeObjects.push({ css: cssObject, mesh: mesh, ringMesh: ring });
    cssObject.element.style.pointerEvents = 'auto'; ring.material.opacity = 0.9; cssObject.element.classList.remove('active-reading');
    new TWEEN.Tween(cssObject.scale).to({x: 1, y: 1, z: 1}, 500).easing(TWEEN.Easing.Back.Out).start();
    new TWEEN.Tween(mesh.scale).to({x: 1, y: 1, z: 1}, 500).easing(TWEEN.Easing.Back.Out).start();
    new TWEEN.Tween(ring.scale).to({x: 1, y: 1, z: 1}, 500).easing(TWEEN.Easing.Back.Out).start();
    
    renderSlots();
    document.getElementById('confirm-btn').classList.remove('visible');
}

function renderSlots() {
    const container = document.getElementById('slot-area');
    container.innerHTML = '';
    if (selectionSlot.length === 0) { container.innerHTML = '<div class="slot-placeholder">ç‚¹å‡»ç©ºä¸­çš„ç¢ç‰‡æ‹¼æ¥...</div>'; return;
    }
    selectionSlot.forEach((item, i) => {
        const div = document.createElement('div'); div.className = 'slot-card'; div.draggable = true; div.textContent = item.txt; div.dataset.index = i; 
        div.onclick = () => removeFromSlot(i);
        div.addEventListener('dragstart', handleDragStart); div.addEventListener('dragover', handleDragOver); div.addEventListener('drop', handleDrop); div.addEventListener('dragend', handleDragEnd); div.addEventListener('dragenter', handleDragEnter); div.addEventListener('dragleave', handleDragLeave);
        container.appendChild(div);
    });
}
let dragSrcEl = null;

function handleDragStart(e) { 
    dragSrcEl = this; 
    e.dataTransfer.effectAllowed = 'move'; 
    e.dataTransfer.setData('text/html', this.innerHTML); 
    this.classList.add('dragging');
}

function handleDragOver(e) { 
    if (e.preventDefault) e.preventDefault(); 
    e.dataTransfer.dropEffect = 'move'; 
    return false; 
}

function handleDragEnter(e) { 
    this.classList.add('drag-over'); 
}

function handleDragLeave(e) { 
    this.classList.remove('drag-over');
}

function handleDrop(e) {
    if (e.stopPropagation) e.stopPropagation();

    // åªæœ‰å½“æ‹–æ‹½æºå’Œç›®æ ‡ä¸åŒæ—¶æ‰æ‰§è¡Œ
    if (dragSrcEl !== this) {
        const srcIndex = parseInt(dragSrcEl.dataset.index);
        const targetIndex = parseInt(this.dataset.index);

        if (!isNaN(srcIndex) && !isNaN(targetIndex)) {
            // [æ ¸å¿ƒä¿®æ”¹] ä½¿ç”¨ splice å®ç°â€œç§»åŠ¨/æ’å…¥â€è€Œéâ€œäº¤æ¢â€
            // 1. å…ˆæŠŠå…ƒç´ ä»åŸæ¥çš„ä½ç½®æ‹¿å‡ºæ¥
            const itemToMove = selectionSlot.splice(srcIndex, 1)[0];
            
            // 2. è¿™é‡Œçš„é€»è¾‘å¾®è°ƒï¼šå¦‚æœæ˜¯ä»ä¸Šå¾€ä¸‹æ‹–(src < target)ï¼Œ
            // å› ä¸ºåˆ é™¤äº†ä¸€ä¸ªå…ƒç´ ï¼Œåé¢çš„ç´¢å¼•éƒ½å‡1äº†ï¼Œä½†æˆ‘ä»¬å¸Œæœ›æ’å…¥åœ¨è§†è§‰ç›®æ ‡çš„ä½ç½®
            // ä¸è¿‡åœ¨ UI äº¤äº’ä¸Šï¼Œç›´æ¥æ’å…¥åˆ° targetIndex é€šå¸¸ç¬¦åˆç›´è§‰ï¼ˆæ’å…¥åˆ°ç›®æ ‡ä½ç½®ä¹‹å‰ï¼‰
            selectionSlot.splice(targetIndex, 0, itemToMove);
            
            // 3. ç«‹å³åˆ·æ–° UI å’Œé€»è¾‘æ£€æµ‹
            renderSlots(); 
            checkCombination();
        }
    }
    return false;
}

function handleDragEnd(e) { 
    const cols = document.querySelectorAll('.slot-card');
    cols.forEach(col => { 
        col.classList.remove('drag-over'); 
        col.classList.remove('dragging'); 
    });
    dragSrcEl = null;
}

// ================== æ ¸å¿ƒé€»è¾‘ ==================
function checkCombination() {
    if (selectionSlot.length === 0) return;
    // æ‹¼è´´æ¨¡å¼
    if (currentMode === 'collage') {
        if (selectionSlot.length >= 3) {
            showConfirmButton(null, 'collage');
        } else {
            document.getElementById('confirm-btn').classList.remove('visible');
        }
        return;
    }

    // æ­£å¸¸æ¨¡å¼
    const targetGroupId = selectionSlot[0].groupId;
    const isHomogeneous = selectionSlot.every(s => s.groupId === targetGroupId);

    if (!isHomogeneous) {
        document.getElementById('confirm-btn').classList.remove('visible');
        if (selectionSlot.length === MAX_SLOTS) {
            mismatchCount++;
            if(mismatchCount >= 2) document.getElementById('hint-btn').classList.add('visible');
            showToast("çŸ¿çŸ³ä¸åŒ¹é…ï¼Œè¯·é‡é€‰", "error");
        }
        return;
    }

    const groupData = allGroups.find(g => g.id === targetGroupId);
    if (selectionSlot.length === groupData.lines.length) {
        let correct = true;
        for(let i=0; i<selectionSlot.length; i++) { if(selectionSlot[i].idx !== i) correct = false;
        }

        if (correct) {
            showConfirmButton(targetGroupId, 'normal');
        } else {
            orderErrorCount++;
            if (orderErrorCount >= 4) {
                selectionSlot.sort((a, b) => a.idx - b.idx);
                renderSlots(); 
                showConfirmButton(targetGroupId, 'normal'); showToast("æ™ºèƒ½è¾…åŠ©ï¼šå·²è‡ªåŠ¨æ’åº", "success");
            } else {
                showToast("é¡ºåºé”™ä¹±", "error");
            }
        }
    }
}

function triggerHint() {
    if (currentMode === 'collage') return;
    document.getElementById('hint-btn').classList.remove('visible');
    mismatchCount = 0; 
    const counts = {}; selectionSlot.forEach(item => { counts[item.groupId] = (counts[item.groupId] || 0) + 1; });
    let targetGroupId = null;
    for(let gid in counts) { if(counts[gid] >= 2) { targetGroupId = gid; break;
    } }
    if(!targetGroupId && activeGroups.length > 0) { const randomGroup = activeGroups[Math.floor(Math.random() * activeGroups.length)]; targetGroupId = randomGroup.id;
    }

    if(targetGroupId) {
        highlightGroup(targetGroupId);
        showToast("æ­£åœ¨å…±é¸£ç›®æ ‡è¯—æ­Œ...", "warning");
    }
}

// ========== åŒæ­¥å‘¼å¸å…±é¸£æ•ˆæœ ==========
function highlightGroup(targetGroupId) {
    currentHintGroupId = targetGroupId; // [æ–°å¢] è®°å½•å½“å‰æç¤ºçš„ç›®æ ‡ID
    // [æ–°å¢] å¯åŠ¨å‘¼å¸éŸ³æ•ˆ
    SoundManager.startResonance();

    activeObjects.forEach(obj => {
        if(obj.css.userData.groupId === targetGroupId) {
            const tweenScale = new TWEEN.Tween(obj.css.scale).to({x: 1.3, y: 1.3, z: 1.3}, 1500).easing(TWEEN.Easing.Quadratic.InOut).yoyo(true).repeat(Infinity).start();
            const tweenMeshScale = new TWEEN.Tween(obj.mesh.scale).to({x: 1.3, y: 1.3, z: 1.3}, 1500).easing(TWEEN.Easing.Quadratic.InOut).yoyo(true).repeat(Infinity).start();
            const tweenEmissive = new TWEEN.Tween(obj.mesh.material.emissive).to({ r: 0.5, g: 0.4, b: 0 }, 1500).easing(TWEEN.Easing.Quadratic.InOut).yoyo(true).repeat(Infinity).start();
          
            obj.css.userData.resonanceTween = tweenScale;
            obj.css.userData.resonanceMeshTween = tweenMeshScale;
            obj.css.userData.resonanceEmissiveTween = tweenEmissive;
        }
    });
    const slotContainer = document.getElementById('slot-area');
    const slots = slotContainer.children; 
    selectionSlot.forEach((item, index) => {
        if(item.groupId === targetGroupId && slots[index]) {
            slots[index].classList.add('hint-active');
        }
    });
    // ä¿®æ”¹ç‚¹ï¼šæç¤ºæŒç»­æ—¶é—´æ”¹ä¸º10ç§’
    setTimeout(() => { stopResonance(targetGroupId); }, 10000);
}

function stopResonance(targetGroupId) {
    // [æ–°å¢] å¦‚æœåœæ­¢çš„æ˜¯å½“å‰æç¤ºç»„ï¼Œåˆ™é‡ç½®å…¨å±€çŠ¶æ€
    if (currentHintGroupId === targetGroupId) {
        currentHintGroupId = null;
    }

    // [æ–°å¢] åœæ­¢å‘¼å¸éŸ³æ•ˆå¹¶é”€æ¯æŒ¯è¡å™¨
    SoundManager.stopResonance();

    activeObjects.forEach(obj => {
        if(obj.css.userData.groupId === targetGroupId && obj.css.userData.resonanceTween) {
            obj.css.userData.resonanceTween.stop(); obj.css.userData.resonanceMeshTween.stop(); obj.css.userData.resonanceEmissiveTween.stop();
            new TWEEN.Tween(obj.css.scale).to({x:1, y:1, z:1}, 500).start();
            new TWEEN.Tween(obj.mesh.scale).to({x:1, y:1, z:1}, 500).start();
            new TWEEN.Tween(obj.mesh.material.emissive).to({r:0, g:0, b:0}, 500).start();
           
            delete obj.css.userData.resonanceTween;
        }
    });
    const slots = document.querySelectorAll('.slot-card');
    slots.forEach(s => s.classList.remove('hint-active'));
}

function showToast(msg, className) {
    SoundManager.playAlert();
    const t = document.getElementById('toast'); const tMsg = document.getElementById('toast-message');
    tMsg.textContent = msg; t.className = ''; t.classList.add(className);
    void t.offsetWidth; t.classList.add('visible'); setTimeout(() => { t.classList.remove('visible'); }, 2000);
}

function showConfirmButton(id, type) {
    const btn = document.getElementById('confirm-btn');
    btn.classList.add('visible');
    if (type === 'collage') {
        btn.textContent = "è‡ªç”±æç‚¼"; btn.style.borderColor = "#ff99cc";
        btn.style.color = "#ff99cc";
    } else {
        btn.textContent = "æç‚¼è¯—æ­Œæ™¶ä½“"; btn.style.borderColor = "#66ff66";
        btn.style.color = "#66ff66";
    }
    btn.onclick = (e) => {
        // --- ä¿®æ”¹ç‚¹ï¼šç¡®è®¤æ—¶æ’­æ”¾ç«ç„°å£° ---
        SoundManager.playFire();
        // ------------------------------
        e.stopPropagation();
        if (type === 'collage') completeCollage(); else completeGroup(id);
        btn.classList.remove('visible'); btn.onclick = null;
    };
}

function downloadFile(content, filename, mimeType = 'text/plain') {
    const blob = new Blob([content], { type: mimeType });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(url);
}

function getPoemText(item) {
    if (item.type === 'normal') {
        const groupData = allGroups.find(g => g.id === item.id);
        return groupData ? groupData.lines.map(l => l.txt).join('\n') : "Error: Poem not found";
    } else { return item.lines.join('\n');
    }
}

function downloadSinglePoem(index) {
    const item = collectedItems[index];
    const poemText = getPoemText(item);
    
    // [ä¿®æ”¹] å¢åŠ ç½²åæ ¡éªŒé€»è¾‘
    // æ£€æŸ¥æ¡ä»¶ï¼šæ‹¼è´´æ¨¡å¼(collage) ä¸” å½“å‰å†…å­˜ä¸­æ— åå­—(!userSignature)
    if (item.type === 'collage' && !userSignature) {
        // å¼¹å‡ºè¾“å…¥æ¡†
        const inputName = prompt("ã€æ‹¼è´´è¯—ç½²åã€‘\nè¯·è¾“å…¥æ‚¨çš„åå­—ï¼Œå®ƒå°†ä½œä¸ºå…±ç¬”ä½œè€…å°åˆ¶åœ¨è¯—æ­Œæ™¶ä½“ä¸Šï¼š\n(æœ¬æ¬¡è¿è¡ŒæœŸé—´æœ‰æ•ˆï¼Œé‡å¯åé‡ç½®)", "åŒ¿åé£è¡Œå‘˜");
        
        if (inputName && inputName.trim() !== "") {
            userSignature = inputName.trim(); // æ›´æ–°å†…å­˜å˜é‡
            
            // åå­—å½•å…¥æˆåŠŸåï¼Œç»§ç»­æ‰§è¡Œä¿å­˜
            generateAndSaveCardImage(poemText, item.type, item.id || '0');
        }
        // å¦‚æœç”¨æˆ·ç‚¹å‡»å–æ¶ˆï¼Œåˆ™ä¸æ‰§è¡Œä¸‹è½½
    } else {
        // æ­£å¸¸æ¨¡å¼ æˆ– å†…å­˜ä¸­å·²æœ‰åå­—ï¼Œç›´æ¥ä¿å­˜
        generateAndSaveCardImage(poemText, item.type, item.id || '0');
    }
}

function downloadAllPoems() {
    if (collectedItems.length === 0) { showToast("æš‚æ— æ•°æ®å¯ä¾›ä¸‹è½½", "warning"); return;
    }
    const allData = collectedItems.map((item, index) => {
        return `--- ${item.type === 'collage' ? 'æ‹¼è´´è¯—' : 'è¯—æ­Œ'} #${index + 1} ---\n${getPoemText(item)}\n\n`;
    }).join('');
    downloadFile(allData, 'å¹»æƒ³æœº_å…¨éƒ¨å·²æ”¶é›†è¯—æ­Œ.txt', 'text/plain');
    showToast("å·²å¼€å§‹ä¸‹è½½å…¨éƒ¨æ”¶é›†æ•°æ®", "success");
}

// æ–°å¢å‡½æ•°ï¼šä¸‹è½½æŒ‡å®šæ¨¡å¼çš„æ‰€æœ‰æ•°æ®
function downloadSpecificMode(mode) {
    let sourceData = [];
    if (mode === 'normal') {
        sourceData = GameData.normal.collected;
    } else {
        sourceData = GameData.collage.collected;
    }

    if (!sourceData || sourceData.length === 0) {
        showToast("è¯¥æ¨¡å¼ä¸‹æš‚æ— æ”¶é›†", "warning");
        return;
    }

    const allData = sourceData.map((item, index) => {
        return `--- ${item.type === 'collage' ? 'æ‹¼è´´è¯—' : 'è¯—æ­Œ'} #${index + 1} ---\n${getPoemText(item)}\n\n`;
    }).join('');
    
    const filename = `å¹»æƒ³æœº_${mode === 'normal' ? 'æ­£å¸¸æ¨¡å¼' : 'æ‹¼è´´æ¨¡å¼'}_å…¨é›†.txt`;
    downloadFile(allData, filename, 'text/plain');
    showToast("ä¸‹è½½å·²å¼€å§‹", "success");
}
// [ä¿®æ”¹] ç¦»çº¿ç”Ÿæˆè¯—æ­Œæ™¶ä½“å›¾ç‰‡çš„åŠŸèƒ½ (æ­£æ–¹å½¢ã€æ— è¾¹æ¡†ã€åŠ¨æ€ç½²å)
function generateAndSaveCardImage(text, type, id) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const width = 800;
    const height = 800; 
    canvas.width = width;
    canvas.height = height;

    // 1. ç¡®å®šèƒŒæ™¯é¢œè‰²
    let hue = 0;
    let bgGradient;
    
    if (type === 'normal') {
        const seed = parseInt(id.replace('g', '')) || 0;
        hue = (seed * 137.5) % 360; 
        bgGradient = ctx.createLinearGradient(0, 0, width, height);
        bgGradient.addColorStop(0, `hsl(${hue}, 40%, 15%)`);
        bgGradient.addColorStop(1, `hsl(${hue + 40}, 50%, 5%)`);
    } else {
        bgGradient = ctx.createLinearGradient(0, 0, width, height);
        bgGradient.addColorStop(0, '#2a0a1a');
        bgGradient.addColorStop(1, '#1a050a');
    }

    // 2. å¡«å……èƒŒæ™¯
    ctx.fillStyle = bgGradient;
    ctx.fillRect(0, 0, width, height);

    // 3. ç»˜åˆ¶è£…é¥°æ€§å…‰æ™• (ä¸­å¿ƒ)
    const glow = ctx.createRadialGradient(width/2, height/2, 50, width/2, height/2, 600);
    glow.addColorStop(0, 'rgba(255,255,255,0.1)');
    glow.addColorStop(1, 'transparent');
    ctx.fillStyle = glow;
    ctx.fillRect(0, 0, width, height);

    // 4. ç»˜åˆ¶æ–‡å­—
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    ctx.font = "45px 'Songti SC', 'SimSun', serif";
    const lineHeight = 90;
    const lines = text.split('\n');
    
    const totalTextHeight = lines.length * lineHeight;
    let startY = (height - totalTextHeight) / 2;

    ctx.shadowColor = "rgba(255,255,255,0.8)";
    ctx.shadowBlur = 15;
    lines.forEach((line, i) => {
        ctx.fillText(line, width / 2, startY + i * lineHeight);
    });

    // 5. [æ ¸å¿ƒä¿®æ”¹] ç»˜åˆ¶åº•éƒ¨ Logo (åŠ¨æ€ç½²åé€»è¾‘)
    ctx.shadowBlur = 0;
    ctx.fillStyle = "rgba(255,255,255,0.4)";
    
    let footerText = "â€”â€” æ›¹åƒ§ Â· å¹» æƒ³ æœº â€”â€”"; // é»˜è®¤æ–‡æœ¬
    
    // å¦‚æœæ˜¯æ‹¼è´´æ¨¡å¼ï¼Œä¸”ç”¨æˆ·å·²è¾“å…¥è¿‡åå­—ï¼Œåˆ™æ˜¾ç¤ºè”åæ¬¾ Logo
    if (type === 'collage' && userSignature) {
        footerText = `â€”â€” ${userSignature} Ã— æ›¹åƒ§ Â· å¹»æƒ³æœº â€”â€”`;
        ctx.font = "20px 'Courier New', monospace"; // ç¨å¾®ç¼©å°å­—ä½“ä»¥é˜²åå­—å¤ªé•¿
    } else {
        ctx.font = "24px 'Courier New', monospace";
    }
    
    ctx.fillText(footerText, width / 2, height - 60);

    // 6. å¯¼å‡ºå¹¶ä¸‹è½½
    const dataURL = canvas.toDataURL('image/png');
    const link = document.createElement('a');
    // å¤„ç†æ–‡ä»¶åï¼Œé˜²æ­¢ç‰¹æ®Šå­—ç¬¦æŠ¥é”™
    const firstLine = lines[0].trim().replace(/[\\/:*?"<>|]/g, "_").substring(0, 15);
    link.download = `å¹»æƒ³æœº_${firstLine}.png`;
    link.href = dataURL;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    
    showToast("å›¾ç‰‡æ™¶ä½“å·²ä¿å­˜", "success");
}
function showCrystalCard(index) {
    const overlay = document.getElementById('crystal-overlay');
    const cardContent = document.getElementById('crystal-card-content');
    
    // 1. è·å–æ•°æ®
    const item = collectedItems[index];
    const text = getPoemText(item);
    
    // 2. æ„å»º HTML å†…å®¹
    cardContent.innerHTML = `
        <div class="crystal-text" id="crystal-text-content">${text.replace(/\n/g, '<br>')}</div>
        <div class="crystal-hint">ç‚¹å‡»ç©ºç™½å¤„å°†æ™¶ä½“å…¥åº“</div>
        <button class="save-img-btn" id="save-card-btn">åˆ†äº«è¿™é¢—è¯—æ­Œæ™¶ä½“</button>
    `;

    // 3. æ ·å¼é€»è¾‘ (ä¿æŒä¸å˜)
    let seed = 0;
    if (item.type === 'normal') {
        seed = parseInt(item.id.replace('g', '')) || 0;
        const hue = (seed * 137.5) % 360; 
        cardContent.style.background = `linear-gradient(135deg, hsl(${hue}, 40%, 15%), hsl(${hue + 40}, 50%, 5%))`;
        cardContent.style.borderColor = `hsl(${hue}, 60%, 60%)`;
        cardContent.style.boxShadow = `0 10px 40px hsl(${hue}, 50%, 10%), inset 0 0 60px rgba(0,0,0,0.5)`;
    } else {
        cardContent.style.background = `linear-gradient(135deg, #2a0a1a, #1a050a)`;
        cardContent.style.borderColor = `#ff3366`;
        cardContent.style.boxShadow = `0 10px 40px rgba(255, 51, 102, 0.3), inset 0 0 60px rgba(255, 0, 50, 0.2)`;
    }

    // 4. [ä¿®æ”¹] ç»‘å®šæŒ‰é’®ç‚¹å‡»äº‹ä»¶ (ä»…æ›´æ–°å†…å­˜å˜é‡)
    const saveBtn = document.getElementById('save-card-btn');
    saveBtn.onclick = (e) => {
        e.stopPropagation(); // é˜²æ­¢å…³é—­å¡ç‰‡
        SoundManager.playHover(); // æ’­æ”¾éŸ³æ•ˆ

        // æ£€æŸ¥æ˜¯å¦éœ€è¦è¾“å…¥åå­—ï¼šæ‹¼è´´æ¨¡å¼ ä¸” å½“å‰æ— ç½²å
        if (item.type === 'collage' && !userSignature) {
            // ä½¿ç”¨æµè§ˆå™¨åŸç”Ÿ prompt è·å–åå­—
            const inputName = prompt("ã€æ‹¼è´´è¯—ç½²åã€‘\nè¯·è¾“å…¥æ‚¨çš„åå­—ï¼Œå®ƒå°†ä½œä¸ºå…±ç¬”ä½œè€…å°åˆ¶åœ¨è¯—æ­Œæ™¶ä½“ä¸Šï¼š", "åŒ¿åé£è¡Œå‘˜");
            
            if (inputName && inputName.trim() !== "") {
                userSignature = inputName.trim();
                
                // [ä¿®æ”¹é‡ç‚¹] è¿™é‡Œä¸å†å†™å…¥ localStorage
                // è¿™æ ·å½“ç”¨æˆ·åˆ·æ–°é¡µé¢æˆ–ç‚¹å‡»â€œé‡å¯ç³»ç»Ÿâ€æ—¶ï¼Œåå­—å°±ä¼šè¢«é—å¿˜
                
                // ä¿å­˜å›¾ç‰‡
                generateAndSaveCardImage(text, item.type, item.id || '0');
            } else {
                // ç”¨æˆ·å–æ¶ˆè¾“å…¥ï¼Œä¸åšæ“ä½œï¼ˆæˆ–æ ¹æ®éœ€æ±‚æ”¹ä¸ºé»˜è®¤ä¿å­˜ï¼‰
            }
        } else {
            // æ­£å¸¸æ¨¡å¼ æˆ– å†…å­˜ä¸­å·²æœ‰ç½²åï¼Œç›´æ¥ä¿å­˜
            generateAndSaveCardImage(text, item.type, item.id || '0');
        }
    };

    const modal = document.getElementById('collection-modal');
    if (modal.classList.contains('visible')) modal.classList.remove('visible');
    overlay.classList.add('visible');
}

function closeCrystalCard() {
    // [æ–°å¢] ç‚¹å‡»å…³é—­/æ”¶é›†æ™¶ä½“å¡ç‰‡æ—¶ï¼Œæ’­æ”¾æ™¶ä½“ç¢°æ’éŸ³æ•ˆ
    SoundManager.playCrystal();

    const overlay = document.getElementById('crystal-overlay');
    if (!overlay.classList.contains('visible')) return;
    overlay.classList.remove('visible');
    if (currentMode === 'normal') {
        setTimeout(() => {
            const activeIds = activeGroups.map(g => g.id);
            const allActiveDone = activeIds.every(id => finishedGroupIds.includes(id));
            if (allActiveDone && finishedGroupIds.length < allGroups.length && activeGroups.length > 0) {
                 GameController.showNextRoundScreen();
            }
 
        }, 500);
    } else { selectionSlot = []; renderSlots();
    }
}

function completeGroup(groupId) {
    finishedGroupIds.push(groupId);
    collectedItems.push({ type: 'normal', id: groupId, lines: null });
    mismatchCount = 0;
    orderErrorCount = 0; 
    document.getElementById('hint-btn').classList.remove('visible');
    document.getElementById('ore-num').textContent = collectedItems.length;
    selectionSlot = []; renderSlots(); updateProgressBar();
    showCrystalCard(collectedItems.length - 1);
}

function completeCollage() {
    const lines = selectionSlot.map(s => s.txt);
    collectedItems.push({ type: 'collage', id: null, lines: lines });
    document.getElementById('ore-num').textContent = collectedItems.length;
    selectionSlot = []; renderSlots();
    showCrystalCard(collectedItems.length - 1);
}

function toggleCollection() {
    const modal = document.getElementById('collection-modal');
    if (modal.classList.contains('visible')) modal.classList.remove('visible');
    else { renderCollectionList(); modal.classList.add('visible'); }
}

function renderCollectionList() {
    const list = document.getElementById('collection-list'); list.innerHTML = '';
    if (collectedItems.length === 0) { list.innerHTML = '<div style="color:#666; text-align:center; padding:20px;">æš‚æ— æ”¶é›†çš„è¯—æ­Œæ™¶ä½“</div>'; return;
    }
    collectedItems.forEach((item, index) => {
        let previewText = "";
        let isCollage = item.type === 'collage';
        if (isCollage) { previewText = item.lines[0] + '...'; } else { const groupData = allGroups.find(g => g.id === item.id); previewText = groupData.lines[0].txt + '...'; }
        const div = document.createElement('div');
        div.className = `collection-item ${isCollage ? 'collage-item' : ''}`;
        div.innerHTML = `<span><span 
        class="collection-idx">#${index + 1}</span>${previewText}</span><button class="download-btn-small" onclick="downloadSinglePoem(${index}); event.stopPropagation();">ä¸‹è½½</button>`;
        // --- ä¿®æ”¹ç‚¹ï¼šç‚¹å‡»åˆ—è¡¨é¡¹æ’­æ”¾æ™¶ä½“å£° ---
        div.onclick = (e) => { 
            SoundManager.playCrystal();
            e.stopPropagation(); 
            showCrystalCard(index); 
        };
        // ---------------------------------
        list.appendChild(div);
    });
}

function updateProgressBar() {
    const pct = (finishedGroupIds.length / allGroups.length) * 100;
    document.getElementById('progress-fill').style.width = pct + '%';
}

function performWarpJump(onCompleteCallback) {
    if(isWarping) return;
    isWarping = true;
    SoundManager.playWarp(4.5);
    const overlay = document.getElementById('warp-overlay');
    
    overlay.classList.remove('stream-active');
    void overlay.offsetWidth; 
    overlay.classList.add('stream-active');

    new TWEEN.Tween(camera.position).to({z: -3000}, 800).easing(TWEEN.Easing.Exponential.In).start();

    setTimeout(() => {
        if(onCompleteCallback) onCompleteCallback();
        setTimeout(() => {
            overlay.classList.remove('stream-active');
            isWarping = false;
            new TWEEN.Tween(camera.position).to({z: 0}, 800).easing(TWEEN.Easing.Exponential.Out).start();
        }, 1200);
    }, 600);
}

function animate() {
    requestAnimationFrame(animate);
    TWEEN.update();

    // ==========================================
    // 1. [å¢å¼º] é©¾é©¶èˆ±æƒ¯æ€§ä¸å°˜åŸƒåŠ¨ç”»
    // ==========================================
    if (!isWarping) {
        // --- A. é©¾é©¶èˆ±æƒ¯æ€§ (Damped Look-Around) ---
        // ç›®æ ‡æ—‹è½¬è§’åº¦ï¼šé¼ æ ‡ä½ç½® * çµæ•åº¦ç³»æ•°
        // 0.00015 æ§åˆ¶æœ€å¤§è½¬åŠ¨è§’åº¦ï¼Œ0.03 æ§åˆ¶é˜»å°¼(æ•°å€¼è¶Šå°è¶Šæœ‰"é‡åŠ›æ„Ÿ")
        const targetRotX = -mouseY * 0.00018; 
        const targetRotY = -mouseX * 0.00018;
        
        camera.rotation.x += (targetRotX - camera.rotation.x) * 0.01;
        camera.rotation.y += (targetRotY - camera.rotation.y) * 0.01;
        
        // æ¨¡æ‹Ÿå¼•æ“æ€ é€Ÿçš„å¾®å°éœ‡åŠ¨
        const time = Date.now() * 0.0005;
        camera.position.x += (Math.cos(time * 0.3) * 3.5 - camera.position.x) * 0.02;
        camera.position.y += (Math.sin(time * 0.2) * 3.5 - camera.position.y) * 0.02;

        // --- B. ç©ºé—´å°˜åŸƒå¾®åŠ¨ (Space Dust) ---
        if (dustParticles) {
            // å°˜åŸƒæ•´ä½“ç¼“æ…¢æ—‹æµï¼Œå¢åŠ ç©ºé—´æµåŠ¨æ„Ÿ
            dustParticles.rotation.y += 0.0003; 
            // å°˜åŸƒå‘¼å¸æ•ˆæœ
            const s = 1 + Math.sin(time * 2) * 0.02;
            dustParticles.scale.set(s, s, s);
        }

        // --- C. æ˜Ÿç©ºèƒŒæ™¯ (ä¿æŒåŸæœ‰é€»è¾‘) ---
        if (starField) {
            starField.rotation.z += 0.0005; 
        }
        if (bgGroup && bgGroup.children.length > 0) {
            bgGroup.children.forEach(child => {
                if (child.material.userData && child.material.userData.shader) 
                    child.material.userData.shader.uniforms.time.value += 0.01;
            });
        }
    }

    // ==========================================
    // 2. å°„çº¿æ£€æµ‹ (Raycaster) - å¢å¼ºç‰ˆä¿®å¤
    // ==========================================
    if (!isWarping) {
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(activeObjects.map(o => o.mesh));
        
        let currentRayHit = null;

        if (intersects.length > 0) {
            const hitMesh = intersects[0].object;
            currentRayHit = activeObjects.find(o => o.mesh === hitMesh);
        }

        // --- é€»è¾‘ A: å‘ç°æ–°çš„æ‚¬åœç›®æ ‡ï¼ˆRaycaster ä¼˜å…ˆå‘ç°ï¼ŒDOM ä¿æŒå±•å¼€ï¼‰ ---
        if (currentRayHit && currentRayHit !== hoveredObject) {
            // å¦‚æœæ—§ç›®æ ‡å­˜åœ¨ï¼Œä¸”é¼ æ ‡å½“å‰ä¸åœ¨å…¶ DOM åŒºåŸŸå†…ï¼Œåˆ™è®©å®ƒç¦»å¼€
            if (hoveredObject && !hoveredObject.css.userData.isDomHovered) {
                hoveredObject.css.userData.onLeave();
            }

            hoveredObject = currentRayHit;
            
            // é¦–æ¬¡å‘½ä¸­æ—¶ï¼Œå¦‚æœä¸æ˜¯è¢«ç¦ç”¨çš„ç‰©ä½“ï¼Œåˆ™è§¦å‘ onEnter
            // é¿å…é‡å¤è§¦å‘ onEnterï¼Œå¦‚æœé¼ æ ‡å·²åœ¨ DOM ä¸Šæ–¹ï¼ˆå³ isDomHovered ä¸º trueï¼‰ï¼Œåˆ™æ— éœ€ Raycaster å†è§¦å‘
            if (hoveredObject.css.element.style.pointerEvents !== 'none' && !hoveredObject.css.userData.isDomHovered) {
                hoveredObject.css.userData.onEnter();
            }
        } 
        
        // --- é€»è¾‘ B: ç¦»å¼€äº† Raycaster ç›®æ ‡ï¼ˆä¸¥æ ¼ç”± DOM çŠ¶æ€æ§åˆ¶å…³é—­ï¼‰ ---
        if (hoveredObject && currentRayHit !== hoveredObject) {
            // ä¿®å¤ç‚¹ï¼šåªæœ‰å½“ Raycaster ç¦»å¼€äº†ç›®æ ‡ï¼Œå¹¶ä¸”é¼ æ ‡ä¹Ÿä¸åœ¨ DOM åŒºåŸŸå†…æ—¶ï¼Œæ‰è§¦å‘ onLeave
            if (!hoveredObject.css.userData.isDomHovered) {
                hoveredObject.css.userData.onLeave();
                hoveredObject = null;
            }
        }
    }

    // ==========================================
    // 3. [å¢å¼º] è¯—æ­Œæ™¶ä½“å¤åˆæ‚¬æµ® (Organic Floating)
    // ==========================================
    const now = Date.now();
    activeObjects.forEach(obj => {
        const css = obj.css;
        const mesh = obj.mesh;
        const ring = obj.ringMesh;
        const ud = css.userData;

        if (!ud.isHovered) {
            // [ç®—æ³•ä¼˜åŒ–] ä½¿ç”¨å¤åˆæ­£å¼¦æ³¢æ¨¡æ‹Ÿæµä½“ä¸­çš„æ— åºæ¼‚æµ®
            // é¿å…å•ä¸€é¢‘ç‡å¯¼è‡´çš„æœºæ¢°æ„Ÿ
            const t = now * ud.floatSpeed;
            
            // Yè½´ï¼šå åŠ ä¸¤ä¸ªä¸åŒé¢‘ç‡çš„æ³¢
            const floatY = Math.sin(t + ud.floatPhase) * ud.floatAmp 
                         + Math.sin(t * 1.8 + ud.floatPhase) * (ud.floatAmp * 0.3);
            
            // X/Zè½´ï¼šç¼“æ…¢çš„æ¨ªå‘æ¼‚ç§» + å‘¨æœŸæ€§æ‘†åŠ¨
            const floatX = Math.cos(t * 0.7 + ud.floatPhaseX) * (ud.floatAmpX * 0.8)
                         + Math.sin(t * 0.3) * 10;
            const floatZ = Math.sin(t * 0.5 + ud.floatPhaseZ) * (ud.floatAmpZ * 0.8)
                         + Math.cos(t * 0.4) * 10;

            const newX = ud.originPos.x + floatX;
            const newY = ud.originPos.y + floatY;
            const newZ = ud.originPos.z + floatZ;

            css.position.set(newX, newY, newZ);
            mesh.position.set(newX - 40, newY, newZ - 20);
            ring.position.copy(mesh.position);

            // æ—‹è½¬ï¼šä¸‰è½´éšæœºç¼“æ…¢ç¿»æ»š
            mesh.rotation.x += ud.rotSpeed.x;
            mesh.rotation.y += ud.rotSpeed.y;
            mesh.rotation.z += ud.rotSpeed.z;
            
            // æ–‡å­—ç¯åå‘æ—‹è½¬ï¼Œå¸¦å¾®å°é€Ÿåº¦æ³¢åŠ¨
            ring.rotation.y -= ud.ringRotSpeed * (1 + Math.sin(now * 0.0005) * 0.1);
        } else {
            css.lookAt(camera.position);
        }
    });

    AtmosphereManager.update(); 
    renderer.render(scene, camera);
    labelRenderer.render(scene, camera);
}
</script>
</body>
</html>
